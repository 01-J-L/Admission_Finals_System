from flask import Blueprint, render_template, request, flash, redirect, session, url_for, jsonify, current_app, Response, send_file
import mysql.connector
from werkzeug.security import generate_password_hash, check_password_hash
from werkzeug.utils import secure_filename
import datetime
from datetime import timedelta
import base64
import traceback
import secrets
from flask_mail import Message
import os
import io
import time


# ----------------- BLUEPRINT SETUP -----------------
auth = Blueprint('auth', __name__)

# ----------------- DATABASE CONNECTION -----------------
def get_db_connection():
    try:
        # print("--- Attempting to Read DB Environment Variables ---")
        env_db_host_from_os = os.getenv('DB_HOST')
        env_db_user_from_os = os.getenv('DB_USER')
        # For logging actual password existence, not value
        # env_db_password_exists_from_os = "Yes" if os.getenv('DB_PASSWORD') else "No"
        env_db_password_from_os = os.getenv('DB_PASSWORD') # Actual password value from env
        env_db_name_from_os = os.getenv('DB_NAME')
        env_db_port_str_from_os = os.getenv('DB_PORT') # Port from env is a string

        # print(f"Raw os.getenv('DB_HOST'): {env_db_host_from_os}")
        # print(f"Raw os.getenv('DB_USER'): {env_db_user_from_os}")
        # print(f"Raw os.getenv('DB_PASSWORD') exists: {env_db_password_exists_from_os}")
        # print(f"Raw os.getenv('DB_NAME'): {env_db_name_from_os}")
        # print(f"Raw os.getenv('DB_PORT'): {env_db_port_str_from_os}")
        # print("--- End of Reading DB Environment Variables ---")

        # Railway specific defaults (derived from typical Railway setups and user-provided connection string)
        RAILWAY_DEFAULT_HOST = 'localhost'
        RAILWAY_DEFAULT_USER = 'root'
        RAILWAY_DEFAULT_PASSWORD = "anime951827"
        RAILWAY_DEFAULT_DB_NAME = "expired" # As per user's connection string example
        RAILWAY_DEFAULT_PORT_STR = '3306' # As per user's connection string example
        
        db_host = env_db_host_from_os
        if env_db_host_from_os and env_db_host_from_os.lower() == 'localhost':
            # print(f"Warning: DB_HOST from environment is '{env_db_host_from_os}'. This is often incorrect for a remote Railway database. "
                #   f"Overriding to use the default Railway proxy host: '{RAILWAY_DEFAULT_HOST}'.")
            db_host = RAILWAY_DEFAULT_HOST
        elif not env_db_host_from_os:
            # print(f"DB_HOST not set in environment. Using default Railway proxy host: '{RAILWAY_DEFAULT_HOST}'.")
            db_host = RAILWAY_DEFAULT_HOST

        db_user = env_db_user_from_os or RAILWAY_DEFAULT_USER
        db_password = env_db_password_from_os or RAILWAY_DEFAULT_PASSWORD
        db_name = env_db_name_from_os or RAILWAY_DEFAULT_DB_NAME
        
        effective_port_str = env_db_port_str_from_os or RAILWAY_DEFAULT_PORT_STR
        
        db_port = int(RAILWAY_DEFAULT_PORT_STR) 
        try:
            db_port = int(effective_port_str)
        except (ValueError, TypeError):
            # print(f"CRITICAL: The determined DB_PORT string ('{effective_port_str}') is not a valid integer. "
                #   f"Falling back to the default Railway port number: {RAILWAY_DEFAULT_PORT_STR}.")
            pass # db_port is already set
        
        # print(f"Attempting DB connection with: Host='{db_host}', Port={db_port}, User='{db_user}', Database='{db_name}'")

        conn = mysql.connector.connect(
            host=db_host,
            user=db_user,
            password=db_password,
            database=db_name,
            port=db_port
        )
        # print("Database connection successful.")
        return conn
    except mysql.connector.Error as err:
        print(f"Database connection error: {err}")
        traceback.print_exc()
        return None

# ----------------- FILE PROCESSING HELPER -----------------
def process_uploaded_file(file_storage, file_description_for_error, max_size_mb=5):
    if file_storage and file_storage.filename != '':
        filename = secure_filename(file_storage.filename)
        mimetype = file_storage.mimetype

        allowed_mimetypes = ['application/pdf', 'image/jpeg', 'image/png', 'image/jpg', 'image/webp']
        allowed_extensions = ['.pdf', '.jpg', '.jpeg', '.png', '.webp']
        file_ext = os.path.splitext(filename)[1].lower()

        if not (mimetype in allowed_mimetypes or file_ext in allowed_extensions):
             return None, None, None, f"Invalid file type for {file_description_for_error} ('{filename}'). Allowed: PDF, JPG, PNG, WEBP."

        file_storage.seek(0, os.SEEK_END)
        file_length = file_storage.tell()
        file_storage.seek(0)

        if file_length == 0:
            return None, None, None, f"{file_description_for_error} ('{filename}') is empty. Please upload a valid file."

        max_bytes = max_size_mb * 1024 * 1024
        if file_length > max_bytes:
            return None, None, None, f"{file_description_for_error} ('{filename}') is too large (max {max_size_mb}MB)."

        file_data = file_storage.read()
        return file_data, filename, mimetype, None
    return None, None, None, None


def save_image_to_uploads(file_storage, prefix='img'):
    """Saves an image file to the UPLOAD_FOLDER and returns the new filename."""
    if not file_storage or not file_storage.filename:
        return None, "No file provided."

    allowed_extensions = {'.png', '.jpg', '.jpeg', '.webp'}
    file_ext = os.path.splitext(file_storage.filename)[1].lower()

    if file_ext not in allowed_extensions:
        return None, f"Invalid image type. Allowed: {', '.join(allowed_extensions)}"
    
    # Create a unique filename to prevent overwrites and conflicts
    timestamp = int(time.time())
    secure_name = secure_filename(os.path.splitext(file_storage.filename)[0])
    new_filename = f"{prefix}_{secure_name}_{timestamp}{file_ext}"
    
    try:
        save_path = os.path.join(current_app.config['UPLOAD_FOLDER'], new_filename)
        file_storage.save(save_path)
        return new_filename, None
    except Exception as e:
        print(f"Error saving file: {e}")
        traceback.print_exc()
        return None, f"Server error while saving file: {e}"

def delete_image_from_uploads(filename):
    """Deletes an image file from the UPLOAD_FOLDER."""
    if not filename:
        return
    try:
        file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], filename)
        if os.path.exists(file_path):
            os.remove(file_path)
    except Exception as e:
        print(f"Error deleting file {filename}: {e}")
        traceback.print_exc()

# ----------------- EMAIL otp -----------------

def send_otp_email(user_email, otp_code):
    sender_name_from_config = current_app.config.get('MAIL_SENDER_NAME', 'Padre Garcia Polytechnic College')
    subject = f"Verify Your PGPC Account - OTP: {otp_code} - {sender_name_from_config}"
    
    try:
        verify_url = url_for('auth.verify_otp_page', _external=True) 
    except RuntimeError:
        verify_url = f"{current_app.config.get('PREFERRED_URL_SCHEME', 'http')}://{current_app.config.get('SERVER_NAME', 'your-domain.com')}/verify-otp"
        if 'your-domain.com' in verify_url: print("Warning: SERVER_NAME might not be correctly set for OTP email links (verify_url).")

    try:
        html_body = render_template(
            'email/otp_verification_email.html',
            user_email=user_email,
            otp_code=otp_code,
            verify_url=verify_url,
            sender_name=sender_name_from_config,
            now=datetime.datetime.now()
        )
    except Exception as e_template:
        print(f"CRITICAL: Email template 'email/otp_verification_email.html' not found or error rendering. Error: {e_template}")
        html_body = f"<p>Dear User,</p><p>Your One-Time Password (OTP) for account verification is: <strong>{otp_code}</strong>. Please enter this OTP on the verification page. This OTP is valid for 10 minutes.</p><p>If you didn't request this, please ignore this email.</p>"
        
    email_sent = _send_email(subject, [user_email], html_body, sender_name_override=sender_name_from_config)
    return email_sent

# ----------------- EMAIL SENDING HELPER FUNCTIONS -----------------

def _send_email(subject, recipients, html_body, sender_name_override=None):
    mail_handler = current_app.extensions.get('mail')
    if not mail_handler:
        print("CRITICAL: Flask-Mail is not configured or initialized. Email not sent.")
        return False
    if not current_app.config.get('MAIL_USERNAME') or not current_app.config.get('MAIL_PASSWORD'):
        print("CRITICAL: MAIL_USERNAME or MAIL_PASSWORD not configured. Email not sent.")
        return False

    effective_sender_name = sender_name_override or current_app.config.get('MAIL_SENDER_NAME')
    default_sender_config = current_app.config.get('MAIL_DEFAULT_SENDER')
    sender_email_address = None

    if isinstance(default_sender_config, tuple):
        sender_email_address = default_sender_config[1]
        if not effective_sender_name: effective_sender_name = default_sender_config[0]
    elif isinstance(default_sender_config, str):
        sender_email_address = default_sender_config

    if not sender_email_address:
        sender_email_address = current_app.config.get('MAIL_USERNAME')
        print(f"Warning: MAIL_DEFAULT_SENDER not fully configured, using MAIL_USERNAME ({sender_email_address}) as sender email.")
    if not effective_sender_name: effective_sender_name = "PGPC System"

    final_sender = (effective_sender_name, sender_email_address) if effective_sender_name else sender_email_address

    try:
        msg = Message(subject=subject, sender=final_sender, recipients=recipients, html=html_body)
        mail_handler.send(msg)
        # print(f"Email '{subject}' successfully dispatched to {recipients}.") # Reduced verbosity
        return True
    except Exception as e_mail_send:
        print(f"CRITICAL: Failed to send email '{subject}' to {recipients}. Error: {e_mail_send}")
        traceback.print_exc()
        return False

def send_application_status_email(applicant_email, applicant_name, new_status, application_id, program_choice=None, exam_status=None, permit_details=None):
    sender_name_from_config = current_app.config.get('MAIL_SENDER_NAME', 'Padre Garcia Polytechnic College')
    app_id_formatted = f"P2025{application_id:04d}"
    subject, template_name = "", ""
    
    email_context = {
        'applicant_name': applicant_name, 'application_id_formatted': app_id_formatted,
        'program_choice': program_choice, 'sender_name': sender_name_from_config,
        'now': datetime.datetime.now(), 'exam_status': exam_status, 'application_status': new_status,
        'application': permit_details 
    }

    status_map = {
        'Approved': ('email/application_approved_email.html', f"Application {app_id_formatted} Approved"),
        'Scheduled': ('email/exam_scheduled_email.html', f"Admission Exam Scheduled for {app_id_formatted}"),
        'Rejected': ('email/application_rejected_email.html', f"Application {app_id_formatted} Update"),
        'Passed': ('email/application_passed_email.html', f"Congratulations! Application {app_id_formatted} Processed: Passed"),
        'Failed': ('email/application_failed_email.html', f"Application {app_id_formatted} Processed: Failed"),
        'Enrolled': ('email/enrollment_approved_email.html', f"Enrollment Confirmed for Application {app_id_formatted}!"),
    }
    exam_status_map = {
        'Passed': ('email/exam_passed_email.html', f"Admission Exam Result for {app_id_formatted}"),
        'Failed': ('email/exam_failed_email.html', f"Admission Exam Result for {app_id_formatted}"),
    }

    if new_status in status_map:
        template_name, base_subject = status_map[new_status]
        subject = base_subject
        if new_status == 'Approved' and exam_status == 'Passed':
            subject = f"Congratulations! Application {app_id_formatted} Approved & Exam Passed"
        elif new_status == 'Rejected' and exam_status == 'Failed':
            subject = f"Application {app_id_formatted} Update (Exam Result)"
        subject += f" - {sender_name_from_config}"
    elif exam_status in exam_status_map and new_status not in status_map: 
        template_name, subject_base = exam_status_map[exam_status]
        subject = f"{subject_base} - {sender_name_from_config}"
    else:
        # Fallback for statuses like 'Pending' or 'In Review' for which we might not typically send emails for every change,
        # but could be triggered if exam_status changes while app_status is one of these.
        # This part ensures we don't crash if new_status is unexpected for email but exam_status is set.
        # However, typically emails are for more definitive changes.
        print(f"Notice: Email not configured for application status '{new_status}' and exam status '{exam_status}'. No email sent for app {app_id_formatted}.")
        return False # Explicitly return False if no template/subject determined

    try:
        html_body = render_template(template_name, **email_context)
    except Exception as e_template:
        print(f"CRITICAL: Email template '{template_name}' not found or error rendering. Error: {e_template}")
        if new_status == 'Scheduled':
             html_body = f"<p>Dear {applicant_name},</p><p>Your admission exam for application {app_id_formatted} has been scheduled. Please check the student portal for details or await further communication.</p>"
        elif new_status == 'Enrolled':
            html_body = f"<p>Dear {applicant_name},</p><p>Congratulations! Your enrollment for application {app_id_formatted} has been confirmed. Welcome to {sender_name_from_config}!</p>"
        else: 
            html_body = f"<p>Dear {applicant_name},</p><p>There is an update on your application {app_id_formatted}. Status: {new_status}. Exam: {exam_status or 'N/A'}.</p>"

    return _send_email(subject, [applicant_email], html_body, sender_name_override=sender_name_from_config)


def send_enrollment_rejection_email(applicant_email, applicant_name, application_id, reason):
    sender_name_from_config = current_app.config.get('MAIL_SENDER_NAME', 'Padre Garcia Polytechnic College')
    app_id_formatted = f"P2025{application_id:04d}"
    subject = f"Update on Your Enrollment for Application {app_id_formatted} - {sender_name_from_config}"
    
    try:
        status_url = url_for('views.application_status_page', _external=True)
    except RuntimeError:
        status_url = f"{current_app.config.get('PREFERRED_URL_SCHEME', 'http')}://{current_app.config.get('SERVER_NAME', 'your-domain.com')}/application-status"

    email_context = {
        'applicant_name': applicant_name,
        'application_id_formatted': app_id_formatted,
        'reason': reason,
        'status_url': status_url,
        'sender_name': sender_name_from_config,
        'now': datetime.datetime.now()
    }
    
    template_name = 'email/enrollment_rejected_email.html'
    try:
        html_body = render_template(template_name, **email_context)
    except Exception as e_template:
        print(f"CRITICAL: Email template '{template_name}' not found or error rendering. Error: {e_template}")
        html_body = (
            f"<p>Dear {applicant_name},</p>"
            f"<p>We are writing to inform you about an update regarding your enrollment for application <strong>{app_id_formatted}</strong>. "
            f"Your enrollment submission has been reviewed, but it could not be approved at this time for the following reason:</p>"
            f"<p><em>{reason}</em></p>"
            f"<p>Your application status has been reverted to 'Passed'. Please log in to your student portal to review any notes from the administrator and make necessary corrections if you wish to resubmit your enrollment documents.</p>"
            f"<p>If you have any questions, please contact the registrar's office.</p>"
        )

    return _send_email(subject, [applicant_email], html_body, sender_name_override=sender_name_from_config)


def send_password_reset_email(user_email, token):
    sender_name_from_config = current_app.config.get('MAIL_SENDER_NAME', 'Padre Garcia Polytechnic College')
    try:
        reset_url = url_for('auth.reset_password_page', token=token, _external=True)
    except RuntimeError as e:
        print(f"CRITICAL: Cannot generate external reset URL. Error: {e}")
        return False, None

    subject = f"Password Reset Request - {sender_name_from_config}"
    html_body = render_template('email/reset_password_email.html', reset_url=reset_url, user_email=user_email, sender_name=sender_name_from_config, now=datetime.datetime.now())
    email_sent = _send_email(subject, [user_email], html_body, sender_name_override=sender_name_from_config)
    return email_sent, reset_url

def send_admin_created_account_email(user_email, user_full_name, temporary_password):
    sender_name_from_config = current_app.config.get('MAIL_SENDER_NAME', 'Padre Garcia Polytechnic College')
    try:
        login_url = url_for('auth.student_login_page', _external=True)
    except RuntimeError as e:
        print(f"CRITICAL: Cannot generate external login URL for admin-created account email. Error: {e}")
        login_url = f"{current_app.config.get('PREFERRED_URL_SCHEME', 'http')}://{current_app.config.get('SERVER_NAME', 'your-domain.com')}/student-login"
        if 'your-domain.com' in login_url: print("Warning: SERVER_NAME might not be correctly set for email links.")

    subject = f"Your PGPC Student Account Has Been Created - {sender_name_from_config}"
    try:
        html_body = render_template('email/admin_created_account_email.html', user_full_name=user_full_name, user_email=user_email, temporary_password=temporary_password, login_url=login_url, sender_name=sender_name_from_config, now=datetime.datetime.now())
    except Exception as e_template:
        print(f"CRITICAL: Email template 'email/admin_created_account_email.html' not found or error rendering. Error: {e_template}")
        html_body = f"<p>Dear {user_full_name},</p><p>An account has been created for you. Email: {user_email}, Temp Password: {temporary_password}. Login: <a href='{login_url}'>{login_url}</a></p>"
    return _send_email(subject, [user_email], html_body, sender_name_override=sender_name_from_config)

# ----------------- ADMIN HELPERS -----------------
def _get_program_list():
    """Fetches a simple list of program titles from the DB for filtering."""
    programs = []
    conn = None
    cursor = None
    try:
        conn = get_db_connection()
        if conn:
            cursor = conn.cursor(dictionary=True)
            # Fetching just the title as it's used for filtering value and display
            cursor.execute("SELECT title FROM programs ORDER BY title ASC")
            programs = cursor.fetchall()
    except Exception as e:
        print(f"Error fetching program list: {e}")
        traceback.print_exc()
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()
    return programs

def _check_and_update_missed_exams():
    """
    Automatically updates the exam_status of scheduled applicants to 'Not Taken'
    if their exam date has passed and their status is still null.
    Returns the number of updated records.
    """
    conn = None
    cursor = None
    updated_count = 0
    try:
        conn = get_db_connection()
        if conn:
            cursor = conn.cursor()
            # CURDATE() gets the current date.
            # We update applicants who were scheduled, have a past exam date, and have no exam status yet.
            query = """
                UPDATE applicants
                SET exam_status = 'Not Taken', last_updated_at = NOW()
                WHERE 
                    (application_status = 'Scheduled' OR (application_status = 'Approved' AND permit_exam_date IS NOT NULL))
                    AND permit_exam_date < CURDATE()
                    AND (exam_status IS NULL OR exam_status = '')
            """
            cursor.execute(query)
            conn.commit()
            updated_count = cursor.rowcount
    except Exception as e:
        print(f"Error checking for missed exams: {e}")
        traceback.print_exc()
        if conn: conn.rollback()
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()
    return updated_count

def _get_all_applications_and_stats():
    """Helper function to fetch all applications and calculate stats."""
    # NEW: Run the check for missed exams before fetching data
    updated_count = _check_and_update_missed_exams()
    if updated_count > 0:
        flash(f"{updated_count} scheduled applicant(s) from past dates were automatically marked as 'Did Not Attend'.", "info")

    applications = []
    stats = {
        'total_applications': 0, 'pending': 0, 'approved': 0, 'scheduled': 0, 
        'rejected': 0, 'passed': 0, 'failed': 0, 'not_taken': 0, 'enrolling': 0,
        'enrolled': 0  # MODIFIED: Add 'enrolled' to stats
    }
    conn = None
    cursor = None
    try:
        conn = get_db_connection()
        if not conn:
            flash("Database connection error.", "danger")
            return [], stats

        cursor = conn.cursor(dictionary=True)
        cursor.execute("""
            SELECT a.*, su.email as student_account_email 
            FROM applicants a 
            LEFT JOIN student_users su ON a.student_user_id = su.id 
            ORDER BY a.submitted_at DESC
        """)
        applications = cursor.fetchall()
        
        stats['total_applications'] = len(applications)
        approved_awaiting_schedule_count = 0
        scheduled_count = 0
        not_taken_count = 0

        for app in applications:
            # Sanitize byte data and format fields for template
            for key, value in app.items(): 
                if isinstance(value, bytes):
                    try: 
                        app[key] = value.decode('utf-8')
                    except UnicodeDecodeError: 
                        app[key] = "Decode Error"
            
            # Format average_family_income for display and search
            if app.get('average_family_income'):
                app['average_family_income'] = app['average_family_income'].replace('_', ' ')
            
            # Count "Did Not Attend"
            if app.get('exam_status') == 'Not Taken':
                not_taken_count += 1

            # Specifically calculate "Approved (Awaiting Schedule)" vs "Scheduled"
            is_scheduled_and_attending = (
                (app.get('application_status') == 'Scheduled' or
                 (app.get('application_status') == 'Approved' and 
                  app.get('permit_exam_date') and 
                  app.get('permit_exam_time') and 
                  app.get('permit_testing_room')))
                and app.get('exam_status') != 'Not Taken'
            )

            if is_scheduled_and_attending:
                scheduled_count += 1
            elif app.get('application_status') == 'Approved':
                approved_awaiting_schedule_count += 1
            
            status_key = app.get('application_status','').lower().replace(' ', '_')
            # MODIFIED: Add 'enrolled' to the list of statuses to count
            if status_key in ['pending', 'rejected', 'passed', 'failed', 'enrolling', 'enrolled']:
                 stats[status_key] += 1
        
        stats['approved'] = approved_awaiting_schedule_count
        stats['scheduled'] = scheduled_count
        stats['not_taken'] = not_taken_count

    except Exception as e:
        flash(f"Error loading application data: {e}", "danger")
        traceback.print_exc()
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()

    return applications, stats

def _render_applications_page(template_name, active_page, applications, stats, programs, page_title="All Applications", filter_status=None, filter_exam_status=None):
    """Helper to render application list pages with filtering."""
    filtered_apps = applications
    if filter_status:
        if filter_status == 'Approved': # Special case for "Approved (Awaiting Schedule)"
            filtered_apps = [
                app for app in applications 
                if app.get('application_status') == 'Approved' and not (
                    app.get('permit_exam_date') and app.get('permit_exam_time') and app.get('permit_testing_room')
                )
            ]
        elif filter_status == 'Scheduled': # Special case for "Scheduled"
            filtered_apps = [
                app for app in applications 
                if (app.get('application_status') == 'Scheduled' or
                    (app.get('application_status') == 'Approved' and 
                     app.get('permit_exam_date') and 
                     app.get('permit_exam_time') and 
                     app.get('permit_testing_room')))
                and app.get('exam_status') != 'Not Taken' # CRUCIAL: Exclude those who didn't attend
            ]
        else:
            filtered_apps = [app for app in applications if app.get('application_status') == filter_status]
    elif filter_exam_status:
        filtered_apps = [app for app in applications if app.get('exam_status') == filter_exam_status]
            
    return render_template(template_name, applications=filtered_apps, stats=stats, active_page=active_page, page_title=page_title, programs=programs)

# ----------------- ADMIN ROUTES -----------------
@auth.route('/admin/dashboard', methods=['GET'])
def admin_dashboard():
    if session.get('user_role') != 'admin':
        flash("⚠️ Log in for admin dashboard.", "warning")
        return redirect(url_for('auth.admin'))
    
    applications, stats = _get_all_applications_and_stats()
    
    return render_template('admin_dashboard2.html', applications=applications, stats=stats, active_page='dashboard')

@auth.route('/president/dashboard', methods=['GET'])
def president_dashboard():
    if session.get('user_role') != 'president':
        flash("⚠️ Unauthorized access.", "warning")
        return redirect(url_for('auth.admin'))
    
    applications, stats = _get_all_applications_and_stats()
    
    passed_applications = [app for app in applications if app.get('application_status') in ['Passed', 'Enrolling']]
    
    return render_template('president_dashboard.html', 
                           applications=passed_applications, 
                           stats=stats, 
                           active_page='dashboard')

# --- NEW ADMIN APPLICATION VIEW ROUTES ---
@auth.route('/admin/applications/all')
def admin_all_applications():
    if session.get('user_role') != 'admin': return redirect(url_for('auth.admin'))
    applications, stats = _get_all_applications_and_stats()
    programs = _get_program_list()
    return _render_applications_page('admin_all_applications.html', 'all_applications', applications, stats, programs, page_title="All Applications")

@auth.route('/admin/applications/pending')
def admin_pending_applications():
    if session.get('user_role') != 'admin': return redirect(url_for('auth.admin'))
    applications, stats = _get_all_applications_and_stats()
    programs = _get_program_list()
    return _render_applications_page('admin_pending.html', 'pending', applications, stats, programs, page_title="Pending Applications", filter_status='Pending')

@auth.route('/admin/applications/approved')
def admin_approved_applications():
    if session.get('user_role') != 'admin': return redirect(url_for('auth.admin'))
    applications, stats = _get_all_applications_and_stats()
    programs = _get_program_list()
    return _render_applications_page('admin_approved.html', 'approved', applications, stats, programs, page_title="Approved Applications", filter_status='Approved')

@auth.route('/admin/applications/scheduled')
def admin_scheduled_applications():
    if session.get('user_role') != 'admin': return redirect(url_for('auth.admin'))
    applications, stats = _get_all_applications_and_stats()
    programs = _get_program_list()
    return _render_applications_page('admin_scheduled.html', 'scheduled', applications, stats, programs, page_title="Scheduled Applications", filter_status='Scheduled')

@auth.route('/admin/applications/not-taken')
def admin_not_taken_applications():
    if session.get('user_role') != 'admin': return redirect(url_for('auth.admin'))
    applications, stats = _get_all_applications_and_stats()
    programs = _get_program_list()
    return _render_applications_page('admin_not_taken.html', 'not_taken', applications, stats, programs, page_title="Did Not Attend Exam", filter_exam_status='Not Taken')

@auth.route('/admin/applications/rejected')
def admin_rejected_applications():
    if session.get('user_role') != 'admin': return redirect(url_for('auth.admin'))
    applications, stats = _get_all_applications_and_stats()
    programs = _get_program_list()
    return _render_applications_page('admin_rejected.html', 'rejected', applications, stats, programs, page_title="Rejected Applications", filter_status='Rejected')

@auth.route('/admin/applications/passed')
def admin_passed_applications():
    if session.get('user_role') not in ['admin', 'president']: return redirect(url_for('auth.admin'))
    applications, stats = _get_all_applications_and_stats()
    programs = _get_program_list()
    return _render_applications_page('admin_passed.html', 'passed', applications, stats, programs, page_title="Passed Applications", filter_status='Passed')

@auth.route('/admin/applications/enrolling')
def admin_enrolling_applications():
    if session.get('user_role') != 'admin': return redirect(url_for('auth.admin'))
    applications, stats = _get_all_applications_and_stats()
    programs = _get_program_list()
    return _render_applications_page('admin_enrolling.html', 'enrolling', applications, stats, programs, page_title="Enrolling Applications", filter_status='Enrolling')

# NEW ROUTE FOR ENROLLED STUDENTS
@auth.route('/admin/applications/enrolled')
def admin_enrolled_applications():
    if session.get('user_role') != 'admin': return redirect(url_for('auth.admin'))
    applications, stats = _get_all_applications_and_stats()
    programs = _get_program_list()
    return _render_applications_page('admin_enrolled.html', 'enrolled', applications, stats, programs, page_title="Enrolled Students", filter_status='Enrolled')

@auth.route('/admin/applications/failed')
def admin_failed_applications():
    if session.get('user_role') != 'admin': return redirect(url_for('auth.admin'))
    applications, stats = _get_all_applications_and_stats()
    programs = _get_program_list()
    return _render_applications_page('admin_failed.html', 'failed', applications, stats, programs, page_title="Failed Applications", filter_status='Failed')

@auth.route('/admin/add-application')
def admin_add_application_page():
    if session.get('user_role') != 'admin': return redirect(url_for('auth.admin'))
    _, stats = _get_all_applications_and_stats() # We only need stats for the sidebar
    today_date = datetime.date.today().strftime('%Y-%m-%d')
    programs_list = _get_program_list()
    return render_template('admin_new_applicants.html', stats=stats, active_page='add_application', today_date_for_form=today_date, programs=programs_list)


@auth.route('/admin/enrollment-review/<int:applicant_id>')
def admin_enrollment_review_page(applicant_id):
    if session.get('user_role') != 'admin':
        return redirect(url_for('auth.admin'))

    conn = None
    cursor = None
    try:
        conn = get_db_connection()
        if not conn:
            flash("Database connection error.", "danger")
            return redirect(url_for('auth.admin_enrolling_applications'))

        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT * FROM applicants WHERE applicant_id = %s", (applicant_id,))
        application = cursor.fetchone()

        if not application or application['application_status'] != 'Enrolling':
            flash("Enrollment application not found or is not in 'Enrolling' status.", "warning")
            return redirect(url_for('auth.admin_enrolling_applications'))
        
        inventory_fields_map = {
            'inventory_gender': 'Gender', 'inventory_age': 'Age', 'inventory_religion': 'Religion', 
            'inventory_complete_address': 'Complete Address', 'inventory_mobile_number': 'Mobile Number', 
            'inventory_facebook_account': 'Facebook Account', 'inventory_interest_hobbies': 'Interests/Hobbies', 
            'inventory_health_condition': 'Health Condition', 'inventory_pre_elementary_school': 'Pre-Elementary School', 
            'inventory_pre_elementary_dates': 'Pre-Elementary Dates', 'inventory_pre_elementary_awards': 'Pre-Elementary Awards', 
            'inventory_elementary_school': 'Elementary School', 'inventory_elementary_dates': 'Elementary Dates', 
            'inventory_elementary_awards': 'Elementary Awards', 'inventory_secondary_school': 'Secondary School', 
            'inventory_secondary_dates': 'Secondary Dates', 'inventory_secondary_awards': 'Secondary Awards', 
            'inventory_vocational_school': 'Vocational School', 'inventory_vocational_dates': 'Vocational Dates', 
            'inventory_vocational_awards': 'Vocational Awards', 'inventory_father_name': "Father's Name", 
            'inventory_father_age': "Father's Age", 'inventory_father_status': "Father's Status", 
            'inventory_father_education': "Father's Education", 'inventory_father_occupation': "Father's Occupation", 
            'inventory_father_contact': "Father's Contact", 'inventory_mother_name': "Mother's Name", 
            'inventory_mother_age': "Mother's Age", 'inventory_mother_status': "Mother's Status", 
            'inventory_mother_education': "Mother's Education", 'inventory_mother_occupation': "Mother's Occupation", 
            'inventory_mother_contact': "Mother's Contact", 'inventory_parents_marital_status': "Parents' Marital Status", 
            'inventory_number_of_children': 'Number of Children', 'inventory_number_of_brothers': 'Number of Brothers', 
            'inventory_number_of_sisters': 'Number of Sisters', 'inventory_guardian_name': "Guardian's Name", 
            'inventory_guardian_relationship': "Guardian's Relationship", 'inventory_guardian_contact': "Guardian's Contact", 
            'inventory_family_income': 'Family Income', 'inventory_favorite_colors': 'Favorite Colors', 
            'inventory_favorite_sports': 'Favorite Sports', 'inventory_favorite_foods': 'Favorite Foods', 
            'inventory_family_description': 'Family Description', 'inventory_emergency_contact_name': 'Emergency Contact Name', 
            'inventory_emergency_contact_number': 'Emergency Contact Number', 'inventory_emergency_contact_relationship': 'Emergency Contact Relationship'
        }

        enrollment_details = {
            'Student Type': application.get('enrollment_student_type'),
            'Year Level': application.get('enrollment_year_level'),
            'Semester': application.get('enrollment_semester')
        }

        inventory_data = {label: application.get(db_field) for db_field, label in inventory_fields_map.items() if application.get(db_field)}

        documents = {
            'Initial': {
                '2x2 Photo': bool(application.get('photo')),
                'SHS Diploma': bool(application.get('shs_diploma_file')),
                'SHS Card': bool(application.get('shs_card_file')),
                'Birth Certificate': bool(application.get('birth_certificate_file'))
            },
            'Enrollment': {
                'Form 138': bool(application.get('enrollment_form138_file')),
                'SHS Diploma (Enrollment)': bool(application.get('enrollment_shs_diploma_file')),
                'Good Moral Cert.': bool(application.get('enrollment_good_moral_file')),
                'PSA Birth Cert.': bool(application.get('enrollment_psa_birth_file')),
                '2x2 Photos': bool(application.get('enrollment_photos_2x2_file')),
                'Entrance Fee Proof': bool(application.get('enrollment_entrance_fee_proof_file')),
                "Voter's ID": bool(application.get('enrollment_voters_id_file')),
                'Verified CBS': bool(application.get('enrollment_cbs_file')),
                'Brgy. Certification': bool(application.get('enrollment_brgy_cert_file'))
            }
        }

        _, stats = _get_all_applications_and_stats()

        return render_template('admin_enrollment_review.html', 
                               application=application, 
                               stats=stats,
                               enrollment_details=enrollment_details,
                               inventory_data=inventory_data,
                               documents=documents,
                               active_page='enrolling')

    except Exception as e:
        flash(f"Error loading enrollment review page: {e}", "danger")
        traceback.print_exc()
        return redirect(url_for('auth.admin_enrolling_applications'))
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()


@auth.route('/admin/enrollment/<int:applicant_id>/action', methods=['POST'])
def admin_enrollment_action(applicant_id):
    if session.get('user_role') != 'admin':
        return jsonify({"success": False, "message": "Unauthorized"}), 401
    
    data = request.get_json()
    action = data.get('action')
    rejection_reason = data.get('reason')

    if action not in ['approve', 'reject']:
        return jsonify({"success": False, "message": "Invalid action."}), 400

    new_status = 'Enrolled' if action == 'approve' else 'Passed'

    conn = None
    cursor = None
    try:
        conn = get_db_connection()
        if not conn:
            return jsonify({"success": False, "message": "Database connection error."}), 500
        
        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT first_name, last_name, email_address, student_user_id, admin_notes, program_choice FROM applicants WHERE applicant_id = %s AND application_status = 'Enrolling'", (applicant_id,))
        app_data = cursor.fetchone()

        if not app_data:
            return jsonify({"success": False, "message": "Application not found or not in 'Enrolling' status."}), 404

        update_sql = "UPDATE applicants SET application_status = %s, last_updated_at = NOW()"
        params = [new_status]
        
        if action == 'reject' and rejection_reason:
            current_notes = app_data.get('admin_notes', '') or ''
            timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M')
            new_note = f"\n--- {timestamp} (Enrollment Rejected) ---\n{rejection_reason}"
            updated_notes = current_notes + new_note
            update_sql += ", admin_notes = %s"
            params.append(updated_notes.strip())

        update_sql += " WHERE applicant_id = %s"
        params.append(applicant_id)
        
        update_cursor = conn.cursor()
        update_cursor.execute(update_sql, tuple(params))
        conn.commit()
        update_cursor.close()
        
        email_to_notify = app_data.get('email_address')
        if not email_to_notify and app_data.get('student_user_id'):
             cursor.execute("SELECT email FROM student_users WHERE id = %s", (app_data['student_user_id'],))
             user_email_data = cursor.fetchone()
             if user_email_data: email_to_notify = user_email_data['email']

        email_sent_msg = ""
        if email_to_notify:
            applicant_name = f"{app_data.get('first_name', '')} {app_data.get('last_name', '')}".strip()
            program_choice = app_data.get('program_choice')
            
            if action == 'reject':
                email_sent = send_enrollment_rejection_email(email_to_notify, applicant_name, applicant_id, rejection_reason)
            else:
                email_sent = send_application_status_email(email_to_notify, applicant_name, new_status, applicant_id, program_choice=program_choice)
            
            email_sent_msg = " Email sent." if email_sent else " Failed to send email."

        message = f"Enrollment for P2025{applicant_id:04d} has been {action}d.{email_sent_msg}"
        return jsonify({"success": True, "message": message})

    except Exception as e:
        if conn: conn.rollback()
        print(f"Error processing enrollment action for {applicant_id}: {e}")
        traceback.print_exc()
        return jsonify({"success": False, "message": "A server error occurred."}), 500
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()


@auth.route('/admin/application/<int:applicant_id>/notes', methods=['POST', 'GET'])
def admin_save_application_notes(applicant_id):
    if session.get('user_role') != 'admin': return jsonify({"success": False, "message": "Unauthorized"}), 401
    
    conn = None; cursor = None
    try:
        conn = get_db_connection()
        if not conn: return jsonify({"success": False, "message": "Database connection error"}), 500
        
        if request.method == 'GET':
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT admin_notes FROM applicants WHERE applicant_id = %s", (applicant_id,))
            result = cursor.fetchone()
            if result:
                return jsonify({"success": True, "notes": result.get('admin_notes') or ""})
            return jsonify({"success": False, "message": "Application not found."}), 404

        if request.method == 'POST':
            data = request.get_json()
            if not isinstance(data, dict):
                return jsonify({"success": False, "message": "Invalid JSON format."}), 400
            notes = data.get('notes', '')

            cursor = conn.cursor()
            cursor.execute("UPDATE applicants SET admin_notes = %s, last_updated_at = NOW() WHERE applicant_id = %s", (notes, applicant_id))
            conn.commit()

            if cursor.rowcount > 0: return jsonify({"success": True, "message": f"Notes for P2025{applicant_id:04d} saved."})
            
            cursor.execute("SELECT COUNT(*) FROM applicants WHERE applicant_id = %s", (applicant_id,))
            if cursor.fetchone()[0] > 0: return jsonify({"success": True, "message": "Notes saved (no change)."})
            
            return jsonify({"success": False, "message": "Application not found."}), 404
            
    except Exception as e:
        print(f"Error handling notes for {applicant_id}: {e}"); traceback.print_exc()
        return jsonify({"success": False, "message": "Server error processing notes."}), 500
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()

@auth.route('/admin/application/<int:applicant_id>/permit-details', methods=['POST'])
def admin_save_permit_details(applicant_id):
    if session.get('user_role') != 'admin': return jsonify({"success": False, "message": "Unauthorized"}), 401
    
    form_permit_exam_date = request.form.get('permit_exam_date')
    form_permit_exam_time = request.form.get('permit_exam_time')
    form_permit_testing_room = request.form.get('permit_testing_room')

    conn = None; cursor = None
    
    try:
        conn = get_db_connection()
        if not conn: return jsonify({"success": False, "message": "Database connection error"}), 500
        
        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT applicant_id FROM applicants WHERE applicant_id = %s", (applicant_id,))
        application = cursor.fetchone()

        if not application:
            return jsonify({"success": False, "message": "Application not found."}), 404

        permit_exam_date_to_db = None
        if form_permit_exam_date and form_permit_exam_date.strip():
            try: 
                permit_exam_date_to_db = datetime.datetime.strptime(form_permit_exam_date, '%Y-%m-%d').date()
            except ValueError: 
                return jsonify({"success": False, "message": "Invalid date format for exam date. Use YYYY-MM-DD."}), 400
        
        # When saving/updating permit details (i.e., rescheduling), reset exam_status to NULL
        cursor.execute("""
            UPDATE applicants 
            SET permit_exam_date=%s, permit_exam_time=%s, permit_testing_room=%s, exam_status=NULL, last_updated_at=NOW() 
            WHERE applicant_id=%s
        """, (
            permit_exam_date_to_db,
            form_permit_exam_time.strip() if form_permit_exam_time else None, 
            form_permit_testing_room.strip() if form_permit_testing_room else None, 
            applicant_id
        ))
        conn.commit()
        
        if cursor.rowcount > 0: 
            cursor.execute("SELECT permit_control_no FROM applicants WHERE applicant_id = %s", (applicant_id,))
            current_pcn_data = cursor.fetchone()
            current_pcn = current_pcn_data['permit_control_no'] if current_pcn_data else None

            saved_data = {
                "permit_control_no": current_pcn,
                "permit_exam_date": str(permit_exam_date_to_db) if permit_exam_date_to_db else None,
                "permit_exam_time": form_permit_exam_time.strip() if form_permit_exam_time else None,
                "permit_testing_room": form_permit_testing_room.strip() if form_permit_testing_room else None
            }
            return jsonify({"success": True, "message": f"Permit details for P2025{applicant_id:04d} saved and exam status reset.", "data": saved_data })

        cursor.execute("SELECT COUNT(*) as count FROM applicants WHERE applicant_id = %s", (applicant_id,))
        check_app_exists = cursor.fetchone()
        if check_app_exists and check_app_exists['count'] > 0:
             return jsonify({"success": True, "message": "Permit details saved (no change detected)."})
        
        return jsonify({"success": False, "message": "Application not found during update attempt."}), 404
    except Exception as e:
        print(f"Error saving permit details for {applicant_id}: {e}"); traceback.print_exc()
        return jsonify({"success": False, "message": "Server error saving permit details."}), 500
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()


@auth.route('/admin/application/<int:applicant_id>/control-number', methods=['POST'])
def admin_save_control_number(applicant_id): # This is likely for the main application control number, not permit.
    if session.get('user_role') != 'admin': return jsonify({"success": False, "message": "Unauthorized"}), 401
    control_number = request.form.get('control_number')
    control_number = control_number.strip() if control_number and control_number.strip() else None
    conn = None; cursor = None
    try:
        conn = get_db_connection()
        if not conn: return jsonify({"success": False, "message": "Database connection error"}), 500
        cursor = conn.cursor()
        cursor.execute("UPDATE applicants SET control_number = %s, last_updated_at = NOW() WHERE applicant_id = %s", (control_number, applicant_id))
        conn.commit()
        if cursor.rowcount > 0: return jsonify({"success": True, "message": f"Control number for P2025{applicant_id:04d} saved."})
        cursor.execute("SELECT COUNT(*) FROM applicants WHERE applicant_id = %s", (applicant_id,))
        if cursor.fetchone()[0] > 0: return jsonify({"success": True, "message": "Control number saved (no change)."})
        return jsonify({"success": False, "message": "Application not found."}), 404
    except Exception as e:
        print(f"Error saving control number for {applicant_id}: {e}"); traceback.print_exc()
        return jsonify({"success": False, "message": "Server error saving control number."}), 500
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()

# ----------------- ADMIN CONTENT MANAGEMENT -----------------
@auth.route('/admin/manage-content')
def admin_manage_content():
    if session.get('user_role') != 'admin': return redirect(url_for('auth.admin'))
    _, stats = _get_all_applications_and_stats()
    return render_template('admin_manage_content.html', stats=stats, active_page='manage_content')

# --- Programs ---
@auth.route('/admin/manage-programs')
def admin_manage_programs():
    if session.get('user_role') != 'admin': return redirect(url_for('auth.admin'))
    _, stats = _get_all_applications_and_stats()
    programs = []
    conn = None
    cursor = None
    try:
        conn = get_db_connection()
        if conn:
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT program_id, title, description, hero_image_filename FROM programs ORDER BY title")
            programs = cursor.fetchall()
    except Exception as e:
        flash(f"Error fetching programs: {e}", "danger")
        traceback.print_exc()
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()
    
    return render_template('admin_manage_programs.html', programs=programs, stats=stats, active_page='manage_programs')

@auth.route('/admin/program/form', defaults={'program_id': None}, methods=['GET', 'POST'])
@auth.route('/admin/program/form/<program_id>', methods=['GET', 'POST'])
def admin_program_form(program_id):
    if session.get('user_role') != 'admin': return redirect(url_for('auth.admin'))
    
    # Local import to prevent circular dependency
    from .views import _get_program_details_from_db

    conn = None; cursor = None
    try:
        if request.method == 'POST':
            conn = get_db_connection()
            if not conn:
                flash("Database connection failed.", "danger")
                return redirect(url_for('auth.admin_manage_programs'))
            
            cursor = conn.cursor()
            
            # --- Get form data ---
            new_program_id = request.form.get('program_id').lower()
            title = request.form.get('title')
            description = request.form.get('description')
            objectives = request.form.getlist('objectives[]')
            careers = request.form.getlist('careers[]')
            course_codes = request.form.getlist('course_codes[]')
            course_names = request.form.getlist('course_names[]')
            course_descs = request.form.getlist('course_descs[]')
            
            # --- Handle Image ---
            image_file = request.files.get('hero_image')
            new_image_filename = None
            if image_file and image_file.filename:
                new_image_filename, error = save_image_to_uploads(image_file, prefix='program')
                if error:
                    flash(f"Image upload error: {error}", "danger")
                    return redirect(request.url)

            if program_id: # --- UPDATE ---
                # Fetch old image filename to delete if a new one is uploaded
                if new_image_filename:
                    cursor.execute("SELECT hero_image_filename FROM programs WHERE program_id = %s", (program_id,))
                    old_filename_row = cursor.fetchone()
                    if old_filename_row and old_filename_row[0]:
                        delete_image_from_uploads(old_filename_row[0])
                
                # Update main program table
                image_sql_part = ", hero_image_filename = %s" if new_image_filename else ""
                update_sql = f"UPDATE programs SET title = %s, description = %s{image_sql_part} WHERE program_id = %s"
                update_params = [title, description]
                if new_image_filename: update_params.append(new_image_filename)
                update_params.append(program_id)
                cursor.execute(update_sql, tuple(update_params))

                # Update related tables (delete and re-insert)
                cursor.execute("DELETE FROM program_objectives WHERE program_id = %s", (program_id,))
                cursor.execute("DELETE FROM program_careers WHERE program_id = %s", (program_id,))
                cursor.execute("DELETE FROM program_courses WHERE program_id = %s", (program_id,))
            
            else: # --- INSERT ---
                cursor.execute(
                    "INSERT INTO programs (program_id, title, description, hero_image_filename, admission_link_endpoint) VALUES (%s, %s, %s, %s, %s)",
                    (new_program_id, title, description, new_image_filename, 'views.existing_or_not')
                )
            
            target_id = program_id or new_program_id
            
            # Re-insert related data for both update and insert
            if objectives:
                cursor.executemany("INSERT INTO program_objectives (program_id, objective_text) VALUES (%s, %s)", [(target_id, o) for o in objectives if o.strip()])
            if careers:
                cursor.executemany("INSERT INTO program_careers (program_id, career_text) VALUES (%s, %s)", [(target_id, c) for c in careers if c.strip()])
            if course_codes and len(course_codes) == len(course_names) == len(course_descs):
                courses_data = [
                    (target_id, code, name, desc) for code, name, desc in zip(course_codes, course_names, course_descs) if code.strip() and name.strip()
                ]
                cursor.executemany("INSERT INTO program_courses (program_id, course_code, course_name, course_description) VALUES (%s, %s, %s, %s)", courses_data)

            conn.commit()
            flash(f"Program '{title}' saved successfully!", "success")
            return redirect(url_for('auth.admin_manage_programs'))

        # --- GET Request ---
        program_data = None
        if program_id:
            program_data = _get_program_details_from_db(program_id)
            if not program_data:
                flash(f"Program with ID '{program_id}' not found.", "danger")
                return redirect(url_for('auth.admin_manage_programs'))
        
        _, stats = _get_all_applications_and_stats()
        return render_template('admin_program_form.html', program=program_data, stats=stats, active_page='manage_programs')

    except Exception as e:
        flash(f"An error occurred: {e}", "danger")
        traceback.print_exc()
        if conn: conn.rollback()
        return redirect(url_for('auth.admin_manage_programs'))
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()

@auth.route('/admin/program/delete/<program_id>', methods=['POST'])
def admin_delete_program(program_id):
    if session.get('user_role') != 'admin': return redirect(url_for('auth.admin'))
    conn = None; cursor = None
    try:
        conn = get_db_connection()
        if not conn:
            flash("Database connection failed.", "danger")
            return redirect(url_for('auth.admin_manage_programs'))
        
        cursor = conn.cursor(dictionary=True)
        # First, get the image filename to delete it from the filesystem
        cursor.execute("SELECT hero_image_filename FROM programs WHERE program_id = %s", (program_id,))
        program = cursor.fetchone()
        if program and program['hero_image_filename']:
            delete_image_from_uploads(program['hero_image_filename'])
        
        # Delete from all related tables. The DB should have cascading deletes, but doing it manually is safer.
        cursor.execute("DELETE FROM program_objectives WHERE program_id = %s", (program_id,))
        cursor.execute("DELETE FROM program_careers WHERE program_id = %s", (program_id,))
        cursor.execute("DELETE FROM program_courses WHERE program_id = %s", (program_id,))
        cursor.execute("DELETE FROM programs WHERE program_id = %s", (program_id,))
        
        conn.commit()
        flash(f"Program '{program_id.upper()}' and all its data have been deleted.", "success")
    except Exception as e:
        flash(f"Error deleting program: {e}", "danger")
        traceback.print_exc()
        if conn: conn.rollback()
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()
    
    return redirect(url_for('auth.admin_manage_programs'))

# --- News ---
@auth.route('/admin/manage-news')
def admin_manage_news():
    if session.get('user_role') != 'admin': return redirect(url_for('auth.admin'))
    _, stats = _get_all_applications_and_stats()
    articles = []
    conn = None; cursor = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT * FROM news_articles ORDER BY publish_date DESC, id DESC")
        articles = cursor.fetchall()
    except Exception as e:
        flash(f"Error fetching news articles: {e}", "danger")
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()
    return render_template('admin_manage_news.html', articles=articles, stats=stats, active_page='manage_news')

@auth.route('/admin/news/form', defaults={'article_id': None}, methods=['GET', 'POST'])
@auth.route('/admin/news/form/<int:article_id>', methods=['GET', 'POST'])
def admin_news_form(article_id):
    if session.get('user_role') != 'admin': return redirect(url_for('auth.admin'))
    conn = None; cursor = None
    try:
        conn = get_db_connection()
        if request.method == 'POST':
            title = request.form.get('title')
            publish_date_str = request.form.get('publish_date')
            publish_date = datetime.datetime.strptime(publish_date_str, '%Y-%m-%d').date() if publish_date_str else None
            description = request.form.get('description')
            read_more_link = request.form.get('read_more_link')
            image_file = request.files.get('image')

            cursor = conn.cursor(dictionary=True)
            new_image_filename = None
            if image_file and image_file.filename:
                new_image_filename, error = save_image_to_uploads(image_file, prefix='news')
                if error:
                    flash(f"Image upload error: {error}", "danger")
                    return redirect(request.url)

            if article_id: # Update
                if new_image_filename:
                    cursor.execute("SELECT image_filename FROM news_articles WHERE id = %s", (article_id,))
                    old_file = cursor.fetchone()
                    if old_file and old_file['image_filename']:
                        delete_image_from_uploads(old_file['image_filename'])
                
                img_sql = ", image_filename = %s" if new_image_filename else ""
                params = [title, publish_date, description, read_more_link]
                if new_image_filename: params.append(new_image_filename)
                params.append(article_id)
                cursor.execute(f"UPDATE news_articles SET title=%s, publish_date=%s, description=%s, read_more_link=%s{img_sql} WHERE id=%s", tuple(params))
            else: # Insert
                cursor.execute("INSERT INTO news_articles (title, publish_date, description, read_more_link, image_filename) VALUES (%s, %s, %s, %s, %s)",
                               (title, publish_date, description, read_more_link, new_image_filename))
            conn.commit()
            flash("News article saved!", "success")
            return redirect(url_for('auth.admin_manage_news'))

        # GET Request
        article = None
        if article_id:
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM news_articles WHERE id = %s", (article_id,))
            article = cursor.fetchone()
            if not article: flash("Article not found.", "danger"); return redirect(url_for('auth.admin_manage_news'))
        
        _, stats = _get_all_applications_and_stats()
        return render_template('admin_news_form.html', article=article, stats=stats, active_page='manage_news')
    except Exception as e:
        flash(f"An error occurred: {e}", "danger")
        traceback.print_exc()
        return redirect(url_for('auth.admin_manage_news'))
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()

@auth.route('/admin/news/delete/<int:article_id>', methods=['POST'])
def admin_delete_news(article_id):
    if session.get('user_role') != 'admin': return redirect(url_for('auth.admin'))
    conn = None; cursor = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT image_filename FROM news_articles WHERE id = %s", (article_id,))
        article = cursor.fetchone()
        if article and article['image_filename']:
            delete_image_from_uploads(article['image_filename'])
        cursor.execute("DELETE FROM news_articles WHERE id = %s", (article_id,))
        conn.commit()
        flash("News article deleted.", "success")
    except Exception as e:
        flash(f"Error deleting article: {e}", "danger")
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()
    return redirect(url_for('auth.admin_manage_news'))

# --- Faculty ---
@auth.route('/admin/manage-faculty')
def admin_manage_faculty():
    if session.get('user_role') != 'admin': return redirect(url_for('auth.admin'))
    _, stats = _get_all_applications_and_stats()
    faculty = []
    conn = None; cursor = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT * FROM faculty ORDER BY category, id")
        faculty = cursor.fetchall()
    except Exception as e:
        flash(f"Error fetching faculty: {e}", "danger")
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()
    return render_template('admin_manage_faculty.html', faculty=faculty, stats=stats, active_page='manage_faculty')

@auth.route('/admin/faculty/form', defaults={'member_id': None}, methods=['GET', 'POST'])
@auth.route('/admin/faculty/form/<int:member_id>', methods=['GET', 'POST'])
def admin_faculty_form(member_id):
    if session.get('user_role') != 'admin': return redirect(url_for('auth.admin'))
    conn = None; cursor = None
    try:
        conn = get_db_connection()
        if request.method == 'POST':
            name = request.form.get('name')
            role = request.form.get('role')
            category = request.form.get('category')
            image_file = request.files.get('image')

            cursor = conn.cursor(dictionary=True)
            new_image_filename = None
            if image_file and image_file.filename:
                new_image_filename, error = save_image_to_uploads(image_file, prefix='faculty')
                if error:
                    flash(f"Image upload error: {error}", "danger")
                    return redirect(request.url)

            if member_id: # Update
                if new_image_filename:
                    cursor.execute("SELECT image_filename FROM faculty WHERE id = %s", (member_id,))
                    old_file = cursor.fetchone()
                    if old_file and old_file['image_filename']:
                        delete_image_from_uploads(old_file['image_filename'])
                
                img_sql = ", image_filename = %s" if new_image_filename else ""
                params = [name, role, category]
                if new_image_filename: params.append(new_image_filename)
                params.append(member_id)
                cursor.execute(f"UPDATE faculty SET name=%s, role=%s, category=%s{img_sql} WHERE id=%s", tuple(params))
            else: # Insert
                cursor.execute("INSERT INTO faculty (name, role, category, image_filename) VALUES (%s, %s, %s, %s)",
                               (name, role, category, new_image_filename))
            conn.commit()
            flash("Faculty/Staff member saved!", "success")
            return redirect(url_for('auth.admin_manage_faculty'))

        # GET Request
        member = None
        if member_id:
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM faculty WHERE id = %s", (member_id,))
            member = cursor.fetchone()
            if not member: flash("Member not found.", "danger"); return redirect(url_for('auth.admin_manage_faculty'))
        
        _, stats = _get_all_applications_and_stats()
        return render_template('admin_faculty_form.html', member=member, stats=stats, active_page='manage_faculty')
    except Exception as e:
        flash(f"An error occurred: {e}", "danger")
        traceback.print_exc()
        return redirect(url_for('auth.admin_manage_faculty'))
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()

@auth.route('/admin/faculty/delete/<int:member_id>', methods=['POST'])
def admin_delete_faculty(member_id):
    if session.get('user_role') != 'admin': return redirect(url_for('auth.admin'))
    conn = None; cursor = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT image_filename FROM faculty WHERE id = %s", (member_id,))
        member = cursor.fetchone()
        if member and member['image_filename']:
            delete_image_from_uploads(member['image_filename'])
        cursor.execute("DELETE FROM faculty WHERE id = %s", (member_id,))
        conn.commit()
        flash("Faculty/Staff member deleted.", "success")
    except Exception as e:
        flash(f"Error deleting member: {e}", "danger")
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()
    return redirect(url_for('auth.admin_manage_faculty'))

# --- Announcements ---
@auth.route('/admin/manage-announcements')
def admin_manage_announcements():
    if session.get('user_role') != 'admin': return redirect(url_for('auth.admin'))
    _, stats = _get_all_applications_and_stats()
    announcements = []
    conn = None; cursor = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT * FROM announcements ORDER BY created_at DESC")
        announcements = cursor.fetchall()
    except Exception as e:
        flash(f"Error fetching announcements: {e}", "danger")
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()
    return render_template('admin_manage_announcements.html', announcements=announcements, stats=stats, active_page='manage_announcements')

@auth.route('/admin/announcement/form', defaults={'announcement_id': None}, methods=['GET', 'POST'])
@auth.route('/admin/announcement/form/<int:announcement_id>', methods=['GET', 'POST'])
def admin_announcement_form(announcement_id):
    if session.get('user_role') != 'admin': return redirect(url_for('auth.admin'))
    conn = None; cursor = None
    try:
        conn = get_db_connection()
        if not conn:
            flash("Database connection failed.", "danger")
            return redirect(url_for('auth.admin_manage_announcements'))

        if request.method == 'POST':
            title = request.form.get('title')
            content = request.form.get('content')
            is_active = 'is_active' in request.form
            image_file = request.files.get('image')

            cursor = conn.cursor(dictionary=True)
            new_image_filename = None
            if image_file and image_file.filename:
                new_image_filename, error = save_image_to_uploads(image_file, prefix='announcement')
                if error:
                    flash(f"Image upload error: {error}", "danger")
                    return redirect(request.url)

            if announcement_id: # Update
                if new_image_filename:
                    cursor.execute("SELECT image_filename FROM announcements WHERE id = %s", (announcement_id,))
                    old_file = cursor.fetchone()
                    if old_file and old_file['image_filename']:
                        delete_image_from_uploads(old_file['image_filename'])
                
                img_sql = ", image_filename = %s" if new_image_filename else ""
                params = [title, content, is_active]
                if new_image_filename: params.append(new_image_filename)
                params.append(announcement_id)
                
                # Use a non-dictionary cursor for the update operation
                update_cursor = conn.cursor()
                update_cursor.execute(f"UPDATE announcements SET title=%s, content=%s, is_active=%s, updated_at=NOW(){img_sql} WHERE id=%s", tuple(params))
                update_cursor.close()

            else: # Insert
                # Use a non-dictionary cursor for the insert operation
                insert_cursor = conn.cursor()
                insert_cursor.execute("INSERT INTO announcements (title, content, is_active, image_filename) VALUES (%s, %s, %s, %s)",
                               (title, content, is_active, new_image_filename))
                insert_cursor.close()
            
            conn.commit()
            flash("Announcement saved successfully!", "success")
            return redirect(url_for('auth.admin_manage_announcements'))

        # GET Request
        announcement = None
        if announcement_id:
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM announcements WHERE id = %s", (announcement_id,))
            announcement = cursor.fetchone()
            if not announcement:
                flash("Announcement not found.", "danger")
                return redirect(url_for('auth.admin_manage_announcements'))
        
        _, stats = _get_all_applications_and_stats()
        return render_template('admin_announcement_form.html', announcement=announcement, stats=stats, active_page='manage_announcements')

    except Exception as e:
        flash(f"An error occurred: {e}", "danger")
        traceback.print_exc()
        if conn: conn.rollback()
        return redirect(url_for('auth.admin_manage_announcements'))
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()

@auth.route('/admin/announcement/delete/<int:announcement_id>', methods=['POST'])
def admin_delete_announcement(announcement_id):
    if session.get('user_role') != 'admin': return redirect(url_for('auth.admin'))
    conn = None; cursor = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor(dictionary=True)
        # First, delete the associated image file from the server
        cursor.execute("SELECT image_filename FROM announcements WHERE id = %s", (announcement_id,))
        announcement = cursor.fetchone()
        if announcement and announcement['image_filename']:
            delete_image_from_uploads(announcement['image_filename'])
        
        # Then, delete the record from the database
        cursor.execute("DELETE FROM announcements WHERE id = %s", (announcement_id,))
        conn.commit()
        flash("Announcement deleted.", "success")
    except Exception as e:
        flash(f"Error deleting announcement: {e}", "danger")
        if conn: conn.rollback()
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()
    return redirect(url_for('auth.admin_manage_announcements'))

@auth.route('/admin/announcement/toggle/<int:announcement_id>', methods=['POST'])
def admin_toggle_announcement(announcement_id):
    if session.get('user_role') != 'admin':
        return jsonify({"success": False, "message": "Unauthorized"}), 401
    
    conn = None; cursor = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        # Toggle the is_active field
        cursor.execute("UPDATE announcements SET is_active = NOT is_active, updated_at=NOW() WHERE id = %s", (announcement_id,))
        conn.commit()
        if cursor.rowcount > 0:
            cursor.execute("SELECT is_active FROM announcements WHERE id = %s", (announcement_id,))
            new_status = cursor.fetchone()[0]
            return jsonify({"success": True, "message": "Status updated", "is_active": bool(new_status)})
        else:
            return jsonify({"success": False, "message": "Announcement not found"}), 404
    except Exception as e:
        print(f"Error toggling announcement {announcement_id}: {e}")
        return jsonify({"success": False, "message": "Server error"}), 500
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()


# --- NEW ROUTE FOR REAL-TIME EMAIL CHECK ---
@auth.route('/admin/check-email', methods=['POST'])
def admin_check_email_exists():
    if session.get('user_role') != 'admin':
        return jsonify({"error": "Unauthorized"}), 401
    
    email = request.json.get('email')
    if not email:
        return jsonify({"exists": False}) # No email to check

    conn = None; cursor = None
    try:
        conn = get_db_connection()
        if not conn:
            return jsonify({"error": "Database connection failed"}), 500
        
        cursor = conn.cursor(dictionary=True)
        cursor.execute("""
            SELECT applicant_id FROM applicants 
            WHERE email_address = %s 
            AND application_status IN ('Pending', 'In Review', 'Approved', 'Scheduled', 'Passed', 'Enrolling')
        """, (email,))
        
        if cursor.fetchone():
            return jsonify({"exists": True})
        else:
            return jsonify({"exists": False})

    except Exception as e:
        print(f"Error checking email existence: {e}")
        return jsonify({"error": "Server error during email check"}), 500
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()

@auth.route('/admin/create_application_by_admin', methods=['POST'])
def admin_add_application_by_admin_action():
    if session.get('user_role') != 'admin': return jsonify({"success": False, "message": "Unauthorized"}), 401
    if request.method != 'POST': return jsonify({"success": False, "message": "Invalid request method."}), 405

    conn = None; cursor = None
    MAX_PHOTO_SIZE_MB, MAX_DOC_SIZE_MB = 5, 5

    try:
        conn = get_db_connection()
        if not conn: return jsonify({"success": False, "message": "Database connection error."}), 500
        
        field_list = [
            'program_choice', 'last_name', 'first_name', 'middle_name', 'date_of_birth', 'place_of_birth',
            'sex', 'civil_status', 'religion', 'citizenship', 'mobile_number', 'email_address',
            'permanent_address_street_barangay', 'permanent_address_city_municipality',
            'permanent_address_province', 'permanent_address_postal_code',
            'cultural_minority_group', 'physical_disability',
            'date_of_application', 'academic_year', 'average_family_income',
            'father_name', 'father_occupation', 'father_company_address', 'father_contact_number',
            'mother_maiden_name', 'mother_occupation', 'mother_company_address', 'mother_contact_number',
            'guardian_name', 'guardian_occupation', 'guardian_company_address', 'guardian_contact_number',
            'senior_high_school', 'senior_high_school_address', 'senior_high_school_track_strand',
            'senior_high_school_year_from', 'senior_high_school_year_to',
            'tertiary_school', 'tertiary_school_address', 'tertiary_course',
            'tertiary_year_from', 'tertiary_year_to', 'agreements', 'final_submission_date'
        ]
        req_text_fields = [f for f in field_list if f not in ['middle_name', 'guardian_name', 'guardian_occupation', 'guardian_company_address', 'guardian_contact_number', 'tertiary_school', 'tertiary_school_address', 'tertiary_course', 'tertiary_year_from', 'tertiary_year_to']]
        req_date_fields = ['date_of_birth', 'date_of_application', 'final_submission_date']

        form_data = {}
        for field in field_list:
            val = request.form.get(field)
            if field in req_text_fields and (not val or not val.strip()): return jsonify({"success": False, "message": f"{field.replace('_',' ').title()} is required."}), 400
            if field in req_date_fields and not val: return jsonify({"success": False, "message": f"{field.replace('_',' ').title()} date is required."}), 400
            if field == 'agreements' and val != 'Yes': return jsonify({"success": False, "message": "Admin must confirm agreement."}), 400
            form_data[field] = val.strip() if val and isinstance(val, str) else val
        
        applicant_email = form_data.get('email_address')
        if not applicant_email: return jsonify({"success": False, "message": "Email is required."}), 400

        cursor = conn.cursor(dictionary=True)
        cursor.execute("""
            SELECT applicant_id FROM applicants 
            WHERE email_address = %s 
            AND application_status IN ('Pending', 'In Review', 'Approved', 'Scheduled', 'Passed', 'Enrolling')
        """, (applicant_email,))
        if cursor.fetchone():
            cursor.close()
            return jsonify({"success": False, "message": f"An active application already exists for the email '{applicant_email}'."}), 409
        cursor.close()

        student_user_cursor = conn.cursor(dictionary=True)
        student_user_cursor.execute("SELECT id FROM student_users WHERE email = %s", (applicant_email,))
        existing_user = student_user_cursor.fetchone()
        
        student_user_id, temp_pass, acc_msg = None, None, ""
        if existing_user:
            student_user_id = existing_user['id']
            student_user_cursor.execute("SELECT applicant_id FROM applicants WHERE student_user_id = %s AND application_status IN ('Pending', 'In Review', 'Approved', 'Scheduled', 'Passed', 'Enrolling')", (student_user_id,))
            if student_user_cursor.fetchone():
                student_user_cursor.close()
                return jsonify({"success": False, "message": f"This email is already linked to an account with an active application."}), 409
            acc_msg = f"Linked to existing student account (ID: {student_user_id})."
        else:
            temp_pass = secrets.token_urlsafe(10)
            hashed_pass = generate_password_hash(temp_pass, method='pbkdf2:sha256')
            insert_user_curs = conn.cursor()
            try:
                insert_user_curs.execute("INSERT INTO student_users (email, password, is_verified, created_at, updated_at) VALUES (%s, %s, TRUE, NOW(), NOW())", (applicant_email, hashed_pass))
                conn.commit()
                student_user_id = insert_user_curs.lastrowid
                if not student_user_id: 
                    conn.rollback()
                    return jsonify({"success": False, "message": "Failed to create student account."}), 500
                acc_msg = f"New student account created (ID: {student_user_id})."
            except mysql.connector.Error as user_err:
                conn.rollback(); print(f"DB Error (User Create): {user_err}"); traceback.print_exc()
                return jsonify({"success": False, "message": f"DB error creating student account: {user_err}"}), 500
            finally:
                if insert_user_curs: insert_user_curs.close()
        
        student_user_cursor.close()

        files_data = {}
        file_fields = {
            'photo': ('2x2 Photo', MAX_PHOTO_SIZE_MB), 
            'shs_diploma_file_input': ('SHS Diploma', MAX_DOC_SIZE_MB),
            'shs_card_file_input': ('SHS Card', MAX_DOC_SIZE_MB),
            'birth_certificate_file_input': ('Birth Certificate', MAX_DOC_SIZE_MB)
        }
        for form_key, (desc, max_size) in file_fields.items():
            file_store = request.files.get(form_key)
            if file_store and file_store.filename:
                data, fname, mtype, err = process_uploaded_file(file_store, desc, max_size)
                if err: return jsonify({"success": False, "message": f"{desc} Error: {err}"}), 400
                files_data[form_key] = {'data': data, 'filename': fname, 'mimetype': mtype}

        db_cols = [
            'student_user_id', 'program_choice', 'last_name', 'first_name', 'middle_name', 'date_of_birth', 'place_of_birth',
            'sex', 'civil_status', 'religion', 'citizenship', 'mobile_number', 'email_address',
            'permanent_address_street_barangay', 'permanent_address_city_municipality',
            'permanent_address_province', 'permanent_address_postal_code',
            'cultural_minority_group', 'physical_disability', 'control_number', 'permit_control_no',
            'date_of_application', 'academic_year', 'average_family_income',
            'father_name', 'father_occupation', 'father_company_address', 'father_contact_number',
            'mother_maiden_name', 'mother_occupation', 'mother_company_address', 'mother_contact_number',
            'guardian_name', 'guardian_occupation', 'guardian_company_address', 'guardian_contact_number',
            'senior_high_school', 'senior_high_school_address', 'senior_high_school_track_strand',
            'senior_high_school_year_from', 'senior_high_school_year_to',
            'tertiary_school', 'tertiary_school_address', 'tertiary_course',
            'tertiary_year_from', 'tertiary_year_to', 'agreements', 'final_submission_date',
            'photo', 'shs_diploma_file', 'shs_diploma_filename', 'shs_diploma_mimetype',
            'shs_card_file', 'shs_card_filename', 'shs_card_mimetype',
            'birth_certificate_file', 'birth_certificate_filename', 'birth_certificate_mimetype',
            'application_status', 'submitted_at', 'last_updated_at', 'exam_status'
        ]
        
        final_insert_vals = []
        now_dt = datetime.datetime.now()
        for col in db_cols:
            if col == 'student_user_id': final_insert_vals.append(student_user_id)
            elif col == 'control_number': final_insert_vals.append(None) 
            elif col == 'permit_control_no': final_insert_vals.append(None)
            elif col == 'photo': final_insert_vals.append(files_data.get('photo', {}).get('data'))
            elif col == 'shs_diploma_file': final_insert_vals.append(files_data.get('shs_diploma_file_input', {}).get('data'))
            elif col == 'shs_diploma_filename': final_insert_vals.append(files_data.get('shs_diploma_file_input', {}).get('filename'))
            elif col == 'shs_diploma_mimetype': final_insert_vals.append(files_data.get('shs_diploma_file_input', {}).get('mimetype'))
            elif col == 'shs_card_file': final_insert_vals.append(files_data.get('shs_card_file_input', {}).get('data'))
            elif col == 'shs_card_filename': final_insert_vals.append(files_data.get('shs_card_file_input', {}).get('filename'))
            elif col == 'shs_card_mimetype': final_insert_vals.append(files_data.get('shs_card_file_input', {}).get('mimetype'))
            elif col == 'birth_certificate_file': final_insert_vals.append(files_data.get('birth_certificate_file_input', {}).get('data'))
            elif col == 'birth_certificate_filename': final_insert_vals.append(files_data.get('birth_certificate_file_input', {}).get('filename'))
            elif col == 'birth_certificate_mimetype': final_insert_vals.append(files_data.get('birth_certificate_file_input', {}).get('mimetype'))
            elif col == 'application_status': final_insert_vals.append('Pending')
            elif col == 'submitted_at': final_insert_vals.append(now_dt)
            elif col == 'last_updated_at': final_insert_vals.append(now_dt)
            elif col == 'exam_status': final_insert_vals.append(None)
            elif col in form_data: final_insert_vals.append(form_data[col])
            else: final_insert_vals.append(None)

        if len(final_insert_vals) != len(db_cols):
             return jsonify({"success": False, "message": f"Internal Error: Column count mismatch ({len(final_insert_vals)} vs {len(db_cols)})."}), 500

        cursor = conn.cursor()
        query = f"INSERT INTO applicants (`{ '`, `'.join(db_cols) }`) VALUES ({ ', '.join(['%s']*len(db_cols)) })"
        cursor.execute(query, tuple(final_insert_vals))
        new_app_id = cursor.lastrowid
        conn.commit()
        
        email_notif_msg = ""
        if temp_pass and student_user_id:
            full_name = f"{form_data.get('first_name','')} {form_data.get('last_name','_')}".strip()
            email_sent = send_admin_created_account_email(applicant_email, full_name, temp_pass)
            email_notif_msg = " Account credentials email sent." if email_sent else " Failed to send credentials email."

        return jsonify({"success": True, "message": f"Application P2025{new_app_id:04d} added. {acc_msg}{email_notif_msg}"})

    except mysql.connector.Error as err:
        if conn and conn.is_connected(): conn.rollback()
        print(f"DB Error (Admin Add App): {err}"); traceback.print_exc()
        return jsonify({"success": False, "message": f"Database Error: {err}"}), 500
    except Exception as e:
        if conn and conn.is_connected(): conn.rollback()
        print(f"Unexpected Error (Admin Add App): {e}"); traceback.print_exc()
        return jsonify({"success": False, "message": f"Unexpected error: {e}"}), 500
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()

@auth.route('/admin', methods=['GET'])
def admin():
    return render_template("admin.html")

@auth.route('/logout', methods=['GET'])
def logout():
    session.clear()
    flash("✅ You have been logged out.", "success")
    return redirect(url_for('views.home'))

@auth.route('/admin_login', methods=['POST'])
def admin_login():
    username = request.form.get('username')
    password = request.form.get('password')

    ADMIN_USERNAME = os.getenv('ADMIN_USERNAME', 'admin')
    ADMIN_PASSWORD = os.getenv('ADMIN_PASSWORD', 'adminpgpc@2025')
    
    PRESIDENT_USERNAME = os.getenv('PRESIDENT_USERNAME', 'president')
    PRESIDENT_PASSWORD = os.getenv('PRESIDENT_PASSWORD', 'presidentpgpc@2025')

    if username == ADMIN_USERNAME and password == ADMIN_PASSWORD:
        session['user_role'] = 'admin'
        flash("✅ Admin login successful!", "success")
        return redirect(url_for('auth.admin_dashboard'))
    elif username == PRESIDENT_USERNAME and password == PRESIDENT_PASSWORD:
        session['user_role'] = 'president'
        flash("✅ President login successful!", "success")
        return redirect(url_for('auth.president_dashboard'))
    else:
        flash('Invalid admin credentials', "danger")
        return redirect(url_for('auth.admin'))

@auth.route('/admin/application/<int:applicant_id>/print', methods=['GET'])
def admin_print_application_form(applicant_id):
    if session.get('user_role') not in ['admin', 'president']:
        flash("⚠️ Please log in to access this page.", "warning")
        return redirect(url_for('auth.admin'))
    conn = None; cursor = None
    try:
        conn = get_db_connection()
        if not conn: flash("Database connection error.", "danger"); return redirect(url_for('auth.admin_dashboard'))
        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT a.*, su.email as student_account_email FROM applicants a LEFT JOIN student_users su ON a.student_user_id = su.id WHERE a.applicant_id = %s", (applicant_id,))
        app_data = cursor.fetchone()
        if not app_data: flash("Application not found.", "danger"); return redirect(url_for('auth.admin_dashboard'))

        application = app_data.copy()
        string_fields = [
            'program_choice', 'last_name', 'first_name', 'middle_name', 'place_of_birth', 'sex', 'civil_status', 
            'religion', 'citizenship', 'mobile_number', 'email_address', 'permanent_address_street_barangay', 
            'permanent_address_city_municipality', 'permanent_address_province', 'permanent_address_postal_code',
            'cultural_minority_group', 'physical_disability', 'average_family_income', 'father_name', 
            'father_occupation', 'father_company_address', 'father_contact_number', 'mother_maiden_name', 
            'mother_occupation', 'mother_company_address', 'mother_contact_number', 'guardian_name', 
            'guardian_occupation', 'guardian_company_address', 'guardian_contact_number', 'senior_high_school', 
            'senior_high_school_address', 'senior_high_school_track_strand', 'senior_high_school_year_from', 
            'senior_high_school_year_to', 'tertiary_school', 'tertiary_school_address', 'tertiary_course', 
            'tertiary_year_from', 'tertiary_year_to', 'agreements', 'academic_year', 'permit_control_no', 
            'permit_exam_time', 'permit_testing_room', 'control_number', 'application_status', 'exam_status', 'admin_notes'
        ]
        for key in string_fields:
            if key in application and isinstance(application[key], bytes):
                try: application[key] = application[key].decode('utf-8')
                except UnicodeDecodeError: application[key] = f"Undecodable ({len(application[key])} bytes)"
            elif key in application and application[key] is not None and not isinstance(application[key], (str, int, float, datetime.date, datetime.datetime)):
                 application[key] = str(application[key])

        if application.get('photo') and isinstance(application['photo'], bytes):
            fmt = "jpeg"
            if application['photo'].startswith(b'\x89PNG\r\n\x1a\n'): fmt = "png"
            application['photo_base64'] = f"data:image/{fmt};base64,{base64.b64encode(application['photo']).decode('utf-8')}"
        else: application['photo_base64'] = None

        date_fields_display = ['date_of_birth', 'date_of_application', 'final_submission_date', 'permit_exam_date']
        datetime_fields_display = ['submitted_at', 'decision_date', 'last_updated_at']
        for field in date_fields_display + datetime_fields_display:
            val = application.get(field)
            if isinstance(val, (datetime.datetime, datetime.date)):
                application[field + '_formatted'] = val.strftime('%B %d, %Y' if field in date_fields_display else '%Y-%m-%d %I:%M %p')
            elif val: application[field + '_formatted'] = str(val)
            else: application[field + '_formatted'] = 'N/A'
        
        all_expected_for_template = string_fields + date_fields_display + datetime_fields_display
        for key in all_expected_for_template:
            application.setdefault(key, '')
            application.setdefault(key + '_formatted', 'N/A' if application[key] == '' else str(application[key]))

        return render_template('printable_application_form.html', application=application)
    except Exception as e:
        flash(f"Error printing application: {e}", "danger"); traceback.print_exc()
        return redirect(url_for('auth.admin_dashboard'))
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()

# ----------------- STUDENT AUTHENTICATION ROUTES -----------------
@auth.route('/create-student-account', methods=['GET', 'POST'])
def create_student_account_page(): 
    if 'student_id' in session: return redirect(url_for('views.application_status_page'))
    if request.method == 'POST':
        email, password, confirm_password = request.form.get('email'), request.form.get('password'), request.form.get('confirm_password')
        if not all([email, password, confirm_password]): flash('Please fill out all fields.', 'warning'); return redirect(url_for('auth.create_student_account_page'))
        if password != confirm_password: flash('Passwords do not match.', 'danger'); return redirect(url_for('auth.create_student_account_page'))
        if len(password) < 8: flash('Password must be at least 8 characters long.', 'danger'); return redirect(url_for('auth.create_student_account_page'))
        
        hashed_password = generate_password_hash(password, method='pbkdf2:sha256')
        otp_code = f"{secrets.randbelow(1000000):06d}" 
        otp_expiry = datetime.datetime.now() + timedelta(minutes=10)

        conn = None; cursor = None
        try:
            conn = get_db_connection()
            if not conn: flash("Database error.", "danger"); return redirect(url_for('auth.create_student_account_page'))
            cursor = conn.cursor(dictionary=True) 
            cursor.execute("SELECT email, is_verified FROM student_users WHERE email = %s", (email,))
            existing_user = cursor.fetchone()

            if existing_user:
                if existing_user['is_verified']:
                    flash('Email already registered and verified. Please log in.', 'danger')
                    return redirect(url_for('auth.student_login_page'))
                else:
                    cursor.execute("""
                        UPDATE student_users 
                        SET password = %s, otp_code = %s, otp_expiry = %s, updated_at = NOW()
                        WHERE email = %s
                    """, (hashed_password, otp_code, otp_expiry, email))
                    conn.commit()
                    email_sent = send_otp_email(email, otp_code)
                    if email_sent:
                        flash('Account existed but was not verified. A new OTP has been sent to your email. Please verify to continue.', 'info')
                    else:
                        flash('Failed to send OTP email. Please try again later.', 'danger')
                    session['pending_verification_email'] = email 
                    return redirect(url_for('auth.verify_otp_page'))
            
            cursor.execute("""
                INSERT INTO student_users 
                (email, password, created_at, updated_at, otp_code, otp_expiry, is_verified) 
                VALUES (%s, %s, NOW(), NOW(), %s, %s, %s)
            """, (email, hashed_password, otp_code, otp_expiry, False))
            conn.commit()
            
            email_sent = send_otp_email(email, otp_code)
            if email_sent:
                flash('✅ Account created! Please check your email for an OTP to verify your account.', 'success')
            else:
                flash('Account created, but failed to send OTP email. Please try verifying later or contact support.', 'warning')
            
            session['pending_verification_email'] = email 
            return redirect(url_for('auth.verify_otp_page'))

        except mysql.connector.Error as db_err:
            if db_err.errno == 1062: 
                 flash('Email already registered. If not verified, try creating account again to resend OTP or try logging in.', 'danger')
            else:
                flash(f'Database error creating account: {db_err}', 'danger')
            traceback.print_exc()
            return redirect(url_for('auth.create_student_account_page'))
        except Exception as e:
            flash(f'Error creating account: {e}', 'danger'); traceback.print_exc()
            return redirect(url_for('auth.create_student_account_page'))
        finally:
            if cursor: cursor.close()
            if conn and conn.is_connected(): conn.close()
    return render_template('create_account.html')

@auth.route('/verify-otp', methods=['GET', 'POST'])
def verify_otp_page():
    email_to_verify = session.get('pending_verification_email')
    if not email_to_verify: 
        email_to_verify = request.form.get('email_for_verification') 
        if not email_to_verify and request.args.get('email'): 
            email_to_verify = request.args.get('email')
            session['pending_verification_email'] = email_to_verify 
        elif not email_to_verify :
            flash("No email found for verification. Please start by creating an account or trying to log in.", "warning")
            return redirect(url_for('auth.create_student_account_page'))

    if request.method == 'POST':
        otp_entered = request.form.get('otp_code')
        email_from_form = request.form.get('email_for_verification')
        if email_from_form and email_from_form != email_to_verify: 
            email_to_verify = email_from_form
            session['pending_verification_email'] = email_to_verify

        if not otp_entered:
            flash("Please enter the OTP.", "warning")
            return render_template('verify_otp.html', email=email_to_verify)

        conn = None; cursor = None
        try:
            conn = get_db_connection()
            if not conn:
                flash("Database connection error.", "danger")
                return render_template('verify_otp.html', email=email_to_verify)
            
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT id, otp_code, otp_expiry, is_verified FROM student_users WHERE email = %s", (email_to_verify,))
            user = cursor.fetchone()

            if not user:
                flash("User not found. Please try creating an account again.", "danger")
                session.pop('pending_verification_email', None) 
                return redirect(url_for('auth.create_student_account_page'))
            
            if user['is_verified']:
                flash("Account already verified. You can log in.", "info")
                session.pop('pending_verification_email', None) 
                return redirect(url_for('auth.student_login_page'))

            db_otp_expiry = user['otp_expiry']
            if isinstance(db_otp_expiry, str): 
                try: db_otp_expiry = datetime.datetime.fromisoformat(db_otp_expiry)
                except ValueError:
                    flash("OTP expiry data error. Contact support.", "danger")
                    return render_template('verify_otp.html', email=email_to_verify)
            
            if not user['otp_code'] or not db_otp_expiry :
                flash("OTP not set or issue with expiry for this account. Try resending OTP.", "danger")
                return render_template('verify_otp.html', email=email_to_verify, show_resend=True)

            if db_otp_expiry < datetime.datetime.now():
                flash("OTP has expired. Please request a new one.", "danger")
                return render_template('verify_otp.html', email=email_to_verify, show_resend=True)

            if user['otp_code'] == otp_entered:
                cursor.execute("""
                    UPDATE student_users 
                    SET is_verified = TRUE, otp_code = NULL, otp_expiry = NULL, updated_at = NOW()
                    WHERE id = %s
                """, (user['id'],))
                conn.commit()
                flash("✅ Account verified successfully! You can now log in.", "success")
                session.pop('pending_verification_email', None) 
                return redirect(url_for('auth.student_login_page'))
            else:
                flash("Invalid OTP. Please try again.", "danger")
                return render_template('verify_otp.html', email=email_to_verify)

        except Exception as e:
            flash(f"An error occurred during OTP verification: {e}", "danger")
            traceback.print_exc()
            return render_template('verify_otp.html', email=email_to_verify)
        finally:
            if cursor: cursor.close()
            if conn and conn.is_connected(): conn.close()

    return render_template('verify_otp.html', email=email_to_verify)

@auth.route('/resend-otp', methods=['POST'])
def resend_otp_action():
    email_to_resend = request.form.get('email') 
    
    if not email_to_resend:
        flash("Email not provided for OTP resend.", "warning")
        email_to_resend = session.get('pending_verification_email')
        if not email_to_resend:
             return redirect(url_for('auth.create_student_account_page'))

    conn = None; cursor = None
    try:
        conn = get_db_connection()
        if not conn:
            flash("Database connection error.", "danger")
            return redirect(url_for('auth.verify_otp_page', email=email_to_resend))

        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT id, is_verified FROM student_users WHERE email = %s", (email_to_resend,))
        user = cursor.fetchone()

        if not user:
            flash(f"No account found for email {email_to_resend}. Please create an account.", "danger")
            session.pop('pending_verification_email', None)
            return redirect(url_for('auth.create_student_account_page'))

        if user['is_verified']:
            flash("Account is already verified. You can log in.", "info")
            session.pop('pending_verification_email', None)
            return redirect(url_for('auth.student_login_page'))

        new_otp_code = f"{secrets.randbelow(1000000):06d}"
        new_otp_expiry = datetime.datetime.now() + timedelta(minutes=10)

        cursor.execute("""
            UPDATE student_users 
            SET otp_code = %s, otp_expiry = %s, updated_at = NOW()
            WHERE id = %s
        """, (new_otp_code, new_otp_expiry, user['id']))
        conn.commit()

        email_sent = send_otp_email(email_to_resend, new_otp_code)
        if email_sent:
            flash("A new OTP has been sent to your email address.", "success")
        else:
            flash("Failed to send new OTP. Please try again later or contact support.", "danger")
        
        session['pending_verification_email'] = email_to_resend 
        return redirect(url_for('auth.verify_otp_page')) 

    except Exception as e:
        flash(f"Error resending OTP: {e}", "danger")
        traceback.print_exc()
        if email_to_resend:
            session['pending_verification_email'] = email_to_resend
        return redirect(url_for('auth.verify_otp_page'))
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()


@auth.route('/student-login', methods=['GET', 'POST'])
def student_login_page(): 
    if 'student_id' in session: return redirect(url_for('views.application_status_page'))
    if request.method == 'POST':
        email, password = request.form.get('email'), request.form.get('password')
        if not email or not password: flash('Please fill out all fields.', 'warning'); return redirect(url_for('auth.student_login_page'))
        conn = None; cursor = None
        try:
            conn = get_db_connection()
            if not conn: flash("Database error.", "danger"); return redirect(url_for('auth.student_login_page'))
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT id, email, password, is_verified FROM student_users WHERE email = %s", (email,))
            user = cursor.fetchone()

            if user:
                if not user['is_verified']:
                    flash('Your account is not verified. Please check your email for an OTP or request a new one on the verification page.', 'warning')
                    session['pending_verification_email'] = email 
                    return redirect(url_for('auth.verify_otp_page')) 

                if check_password_hash(user['password'], password):
                    session['student_id'] = user['id']
                    session['student_email'] = user['email']
                    flash('✅ Login successful!', 'success')
                    session.pop('pending_verification_email', None) 
                    return redirect(url_for('views.application_status_page'))
                else:
                    flash('Invalid email or password.', 'danger')
                    return redirect(url_for('auth.student_login_page'))
            else:
                flash('Invalid email or password.', 'danger')
                return redirect(url_for('auth.student_login_page'))
        except Exception as e:
            flash(f'Login error: {e}', 'danger'); traceback.print_exc()
            return redirect(url_for('auth.student_login_page'))
        finally:
            if cursor: cursor.close()
            if conn and conn.is_connected(): conn.close()
    return render_template('student_login.html')

# ----------------- STUDENT FORGOT/RESET PASSWORD ROUTES -----------------
@auth.route('/forgot-password', methods=['GET', 'POST'])
def forgot_password_request_page(): 
    if request.method == 'POST':
        email = request.form.get('email')
        if not email: flash("Please enter your email.", "warning"); return redirect(url_for('auth.forgot_password_request_page'))
        conn = None; cursor = None
        try:
            conn = get_db_connection()
            if not conn: flash("Database error.", "danger"); return redirect(url_for('auth.forgot_password_request_page'))
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT id FROM student_users WHERE email = %s", (email,))
            user = cursor.fetchone()
            if user:
                token = secrets.token_urlsafe(32)
                expiry = datetime.datetime.now() + timedelta(hours=1)
                cursor.execute("UPDATE student_users SET reset_token = %s, reset_token_expiry = %s WHERE id = %s", (token, expiry, user['id']))
                conn.commit()
                email_sent, reset_url = send_password_reset_email(email, token)
                if email_sent: flash(f"Password reset link sent to {email}.", "success")
                else: flash("Error sending email. Try again later.", "danger"); print(f"Failed reset email to {email}. Link: {reset_url}")
            else:
                flash(f"Email '{email}' not registered.", "danger")
            return redirect(url_for('auth.forgot_password_request_page'))
        except Exception as e:
            flash(f'Error processing request: {e}', 'danger'); traceback.print_exc()
            return redirect(url_for('auth.forgot_password_request_page'))
        finally:
            if cursor: cursor.close()
            if conn and conn.is_connected(): conn.close()
    return render_template('forgot_password_request.html')

@auth.route('/reset-password/<token>', methods=['GET', 'POST'])
def reset_password_page(token): 
    conn = None; cursor = None
    try:
        conn = get_db_connection()
        if not conn: flash("Database error.", "danger"); return redirect(url_for('auth.forgot_password_request_page'))
        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT id, reset_token_expiry FROM student_users WHERE reset_token = %s", (token,))
        user = cursor.fetchone()

        if not user: flash("Invalid token.", "danger"); return redirect(url_for('auth.forgot_password_request_page'))
        
        expiry_time = user.get('reset_token_expiry')
        if isinstance(expiry_time, str): 
            try: expiry_time = datetime.datetime.fromisoformat(expiry_time) 
            except ValueError: 
                flash("Token expiry format error.", "danger"); return redirect(url_for('auth.forgot_password_request_page'))

        if not expiry_time or expiry_time < datetime.datetime.now():
            flash("Token expired.", "danger")
            cursor.execute("UPDATE student_users SET reset_token = NULL, reset_token_expiry = NULL WHERE id = %s", (user['id'],))
            conn.commit()
            return redirect(url_for('auth.forgot_password_request_page'))

        if request.method == 'POST':
            password, confirm_pass = request.form.get('password'), request.form.get('confirm_password')
            if not all([password, confirm_pass]): flash("Fill all fields.", "warning"); return render_template('reset_password_form.html', token=token)
            if password != confirm_pass: flash("Passwords don't match.", "danger"); return render_template('reset_password_form.html', token=token)
            if len(password) < 8: flash('Password too short.', 'danger'); return render_template('reset_password_form.html', token=token)
            
            hashed_pass = generate_password_hash(password, method='pbkdf2:sha256')
            cursor.execute("UPDATE student_users SET password = %s, reset_token = NULL, reset_token_expiry = NULL, updated_at = NOW() WHERE id = %s", (hashed_pass, user['id']))
            conn.commit()
            flash('✅ Password reset! Please log in.', 'success')
            return redirect(url_for('auth.student_login_page'))
        
        return render_template('reset_password_form.html', token=token)

    except Exception as e:
        flash(f'Error resetting password: {e}', 'danger'); traceback.print_exc()
        return redirect(url_for('auth.forgot_password_request_page'))
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()

# ----------------- NEW ROUTE: STUDENT CHANGE PASSWORD (LOGGED IN) -----------------
@auth.route('/change-password', methods=['GET', 'POST'])
def change_password_page():
    if 'student_id' not in session:
        flash("⚠️ Please log in to change your password.", "warning")
        return redirect(url_for('auth.student_login_page'))

    if request.method == 'POST':
        current_password = request.form.get('current_password')
        new_password = request.form.get('new_password')
        confirm_new_password = request.form.get('confirm_new_password')

        # Validation
        if not all([current_password, new_password, confirm_new_password]):
            flash("Please fill out all fields.", "danger")
            return redirect(url_for('auth.change_password_page'))

        if new_password != confirm_new_password:
            flash("New passwords do not match.", "danger")
            return redirect(url_for('auth.change_password_page'))

        if len(new_password) < 8:
            flash("New password must be at least 8 characters long.", "danger")
            return redirect(url_for('auth.change_password_page'))

        student_id = session['student_id']
        conn = None
        cursor = None
        try:
            conn = get_db_connection()
            if not conn:
                flash("Database connection error.", "danger")
                return redirect(url_for('auth.change_password_page'))
            
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT password FROM student_users WHERE id = %s", (student_id,))
            user = cursor.fetchone()

            if not user or not check_password_hash(user['password'], current_password):
                flash("Incorrect current password.", "danger")
                return redirect(url_for('auth.change_password_page'))

            # If current password is correct, update to new password
            hashed_new_password = generate_password_hash(new_password, method='pbkdf2:sha256')
            cursor.execute("UPDATE student_users SET password = %s, updated_at = NOW() WHERE id = %s", (hashed_new_password, student_id))
            conn.commit()
            
            flash("✅ Your password has been changed successfully.", "success")
            return redirect(url_for('views.application_status_page'))

        except Exception as e:
            flash(f"An error occurred: {e}", "danger")
            traceback.print_exc()
            return redirect(url_for('auth.change_password_page'))
        finally:
            if cursor: cursor.close()
            if conn and conn.is_connected(): conn.close()
    
    # For GET request
    return render_template('change_password.html', student_logged_in=True)


# ----------------- APPLICATION FORM SUBMISSION (NEW STUDENT) -----------------
@auth.route('/submit_application', methods=['POST'])
def submit_application():
    if 'student_id' not in session: flash("⚠️ Log in to submit.", "warning"); return redirect(url_for('auth.student_login_page'))
    if request.method != 'POST': return redirect(url_for('views.new_student'))

    conn = None; cursor = None
    student_user_id = session['student_id']
    MAX_PHOTO_SIZE_MB, MAX_DOC_SIZE_MB = 5, 5

    try:
        files_to_upload = {
            'photo': ('2x2 Photo', MAX_PHOTO_SIZE_MB, True), 
            'shs_diploma_file_input': ('SHS Diploma', MAX_DOC_SIZE_MB, True),
            'shs_card_file_input': ('SHS Card', MAX_DOC_SIZE_MB, True),
            'birth_certificate_file_input': ('Birth Certificate', MAX_DOC_SIZE_MB, True)
        }
        processed_files = {}
        for key, (desc, max_size, is_required) in files_to_upload.items():
            file_storage = request.files.get(key)
            data, fname, mtype, err = process_uploaded_file(file_storage, desc, max_size)
            if err: flash(f"⚠️ {err}", "danger"); return redirect(url_for('views.new_student'))
            if is_required and not data: flash(f"⚠️ {desc} is required.", "danger"); return redirect(url_for('views.new_student'))
            if data: processed_files[key] = {'data': data, 'filename': fname, 'mimetype': mtype}

        field_list = [
            'program_choice', 'last_name', 'first_name', 'middle_name', 'date_of_birth', 'place_of_birth',
            'sex', 'civil_status', 'religion', 'citizenship', 'mobile_number', 'email_address',
            'permanent_address_street_barangay', 'permanent_address_city_municipality',
            'permanent_address_province', 'permanent_address_postal_code',
            'cultural_minority_group', 'physical_disability',
            'date_of_application', 'academic_year', 'average_family_income',
            'father_name', 'father_occupation', 'father_company_address', 'father_contact_number',
            'mother_maiden_name', 'mother_occupation', 'mother_company_address', 'mother_contact_number',
            'guardian_name', 'guardian_occupation', 'guardian_company_address', 'guardian_contact_number',
            'senior_high_school', 'senior_high_school_address', 'senior_high_school_track_strand',
            'senior_high_school_year_from', 'senior_high_school_year_to',
            'tertiary_school', 'tertiary_school_address', 'tertiary_course',
            'tertiary_year_from', 'tertiary_year_to', 'agreements', 'final_submission_date'
        ]
        req_text_fields = [f for f in field_list if f not in ['middle_name', 'guardian_name', 'guardian_occupation', 'guardian_company_address', 'guardian_contact_number', 'tertiary_school', 'tertiary_school_address', 'tertiary_course', 'tertiary_year_from', 'tertiary_year_to']]
        req_date_fields = ['date_of_birth', 'date_of_application', 'final_submission_date']
        
        form_data = {}
        for field in field_list:
            val = request.form.get(field)
            if field in req_text_fields and (not val or not val.strip()): flash(f"⚠️ {field.replace('_',' ').title()} is required.", "danger"); return redirect(url_for('views.new_student'))
            if field in req_date_fields and not val: flash(f"⚠️ {field.replace('_',' ').title()} date required.", "danger"); return redirect(url_for('views.new_student'))
            if field == 'agreements' and val != 'Yes': flash("⚠️ Agree to terms.", "danger"); return redirect(url_for('views.new_student'))
            form_data[field] = val.strip() if val and isinstance(val, str) else val

        conn = get_db_connection();
        if not conn: flash("Database error.", "danger"); return redirect(url_for('views.new_student'))
        cursor = conn.cursor()
        cursor.execute("SELECT applicant_id FROM applicants WHERE student_user_id = %s AND application_status IN ('Pending', 'In Review', 'Approved', 'Passed', 'Scheduled', 'Enrolling')", (student_user_id,))
        if cursor.fetchone(): flash("⚠️ Active/Approved/Passed/Scheduled application exists.", "warning"); return redirect(url_for('views.application_status_page'))

        db_cols_app_insert = [
            'student_user_id', 'program_choice', 'last_name', 'first_name', 'middle_name', 'date_of_birth', 'place_of_birth', 'sex', 'civil_status', 
            'religion', 'citizenship', 'mobile_number', 'email_address', 'permanent_address_street_barangay', 
            'permanent_address_city_municipality', 'permanent_address_province', 'permanent_address_postal_code', 
            'cultural_minority_group', 'physical_disability', 'control_number', 'permit_control_no',
            'date_of_application', 'academic_year', 
            'average_family_income', 'father_name', 'father_occupation', 'father_company_address', 'father_contact_number', 
            'mother_maiden_name', 'mother_occupation', 'mother_company_address', 'mother_contact_number', 'guardian_name', 
            'guardian_occupation', 'guardian_company_address', 'guardian_contact_number', 'senior_high_school', 
            'senior_high_school_address', 'senior_high_school_track_strand', 'senior_high_school_year_from', 
            'senior_high_school_year_to', 'tertiary_school', 'tertiary_school_address', 'tertiary_course', 
            'tertiary_year_from', 'tertiary_year_to', 'agreements', 'final_submission_date', 'photo', 
            'shs_diploma_file', 'shs_diploma_filename', 'shs_diploma_mimetype', 'shs_card_file', 'shs_card_filename', 
            'shs_card_mimetype', 'birth_certificate_file', 'birth_certificate_filename', 'birth_certificate_mimetype', 
            'application_status', 'submitted_at', 'last_updated_at', 'exam_status'
        ]
        now_dt = datetime.datetime.now()
        app_insert_vals = [
            student_user_id, form_data.get('program_choice'), form_data.get('last_name'), form_data.get('first_name'), form_data.get('middle_name'),
            form_data.get('date_of_birth'), form_data.get('place_of_birth'), form_data.get('sex'), form_data.get('civil_status'),
            form_data.get('religion'), form_data.get('citizenship'), form_data.get('mobile_number'), form_data.get('email_address'),
            form_data.get('permanent_address_street_barangay'), form_data.get('permanent_address_city_municipality'),
            form_data.get('permanent_address_province'), form_data.get('permanent_address_postal_code'),
            form_data.get('cultural_minority_group'), form_data.get('physical_disability'), None, # control_number
            None, # permit_control_no initially null
            form_data.get('date_of_application'), form_data.get('academic_year'), form_data.get('average_family_income'),
            form_data.get('father_name'), form_data.get('father_occupation'), form_data.get('father_company_address'), form_data.get('father_contact_number'),
            form_data.get('mother_maiden_name'), form_data.get('mother_occupation'), form_data.get('mother_company_address'), form_data.get('mother_contact_number'),
            form_data.get('guardian_name'), form_data.get('guardian_occupation'), form_data.get('guardian_company_address'), form_data.get('guardian_contact_number'),
            form_data.get('senior_high_school'), form_data.get('senior_high_school_address'), form_data.get('senior_high_school_track_strand'),
            form_data.get('senior_high_school_year_from'), form_data.get('senior_high_school_year_to'),
            form_data.get('tertiary_school'), form_data.get('tertiary_school_address'), form_data.get('tertiary_course'),
            form_data.get('tertiary_year_from'), form_data.get('tertiary_year_to'),
            form_data.get('agreements'), form_data.get('final_submission_date'),
            processed_files.get('photo', {}).get('data'),
            processed_files.get('shs_diploma_file_input', {}).get('data'), processed_files.get('shs_diploma_file_input', {}).get('filename'), processed_files.get('shs_diploma_file_input', {}).get('mimetype'),
            processed_files.get('shs_card_file_input', {}).get('data'), processed_files.get('shs_card_file_input', {}).get('filename'), processed_files.get('shs_card_file_input', {}).get('mimetype'),
            processed_files.get('birth_certificate_file_input', {}).get('data'), processed_files.get('birth_certificate_file_input', {}).get('filename'), processed_files.get('birth_certificate_file_input', {}).get('mimetype'),
            'Pending', now_dt, now_dt, None # application_status, submitted_at, last_updated_at, exam_status
        ]
        
        if len(app_insert_vals) != len(db_cols_app_insert):
            flash(f"Internal error: Mismatch {len(app_insert_vals)} vs {len(db_cols_app_insert)}.", "danger"); return redirect(url_for('views.new_student'))

        query = f"INSERT INTO applicants (`{ '`, `'.join(db_cols_app_insert) }`) VALUES ({ ', '.join(['%s']*len(db_cols_app_insert)) })"
        cursor.execute(query, tuple(app_insert_vals))
        conn.commit()
        flash("✅ Application submitted! Check status now.", "success")
        return redirect(url_for('views.application_status_page'))

    except Exception as e:
        flash(f"⚠️ Error submitting: {e}", "danger"); traceback.print_exc()
        return redirect(url_for('views.new_student'))
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()


# ----------------- STUDENT ENROLLMENT ROUTES -----------------
@auth.route('/enrollment-form/<int:applicant_id>', methods=['GET'])
def enrollment_form_page(applicant_id):
    if 'student_id' not in session:
        flash("⚠️ Please log in to access the enrollment form.", "warning")
        return redirect(url_for('auth.student_login_page'))

    student_user_id = session['student_id']
    conn = None
    cursor = None
    try:
        conn = get_db_connection()
        if not conn:
            flash("Database connection error.", "danger")
            return redirect(url_for('views.application_status_page'))
            
        cursor = conn.cursor(dictionary=True)
        # MODIFIED: Expanded query to fetch file existence for checking redundancy
        cursor.execute("""
            SELECT 
                applicant_id, first_name, last_name, middle_name, email_address, program_choice, 
                academic_year, application_status, date_of_birth, place_of_birth, sex, civil_status,
                religion, mobile_number, permanent_address_street_barangay, permanent_address_city_municipality,
                permanent_address_province, senior_high_school, senior_high_school_year_from,
                senior_high_school_year_to, father_name, father_occupation, father_contact_number,
                mother_maiden_name, mother_occupation, mother_contact_number,
                guardian_name, guardian_contact_number,
                shs_diploma_file, shs_card_file, birth_certificate_file, photo
            FROM applicants 
            WHERE applicant_id = %s AND student_user_id = %s
        """, (applicant_id, student_user_id))
        application = cursor.fetchone()
        
        if not application:
            flash("Application not found or you do not have permission.", "danger")
            return redirect(url_for('views.application_status_page'))

        if application['application_status'] != 'Passed':
            flash(f"This application is not ready for enrollment (Status: {application['application_status']}).", "warning")
            return redirect(url_for('views.application_status_page'))

        # NEW: Create a dictionary to track which documents were already submitted
        docs_submitted = {
            'diploma': bool(application.get('shs_diploma_file')),
            'card': bool(application.get('shs_card_file')),  # Corresponds to Form 138
            'birth_cert': bool(application.get('birth_certificate_file')),
            'photo': bool(application.get('photo'))
        }

        return render_template('enrollment_form.html', application=application, docs_submitted=docs_submitted, student_logged_in=True)

    except Exception as e:
        flash(f"An error occurred: {e}", "danger")
        traceback.print_exc()
        return redirect(url_for('views.application_status_page'))
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()


@auth.route('/submit-enrollment/<int:applicant_id>', methods=['POST'])
def submit_enrollment(applicant_id):
    if 'student_id' not in session:
        flash("⚠️ Please log in to submit enrollment.", "warning")
        return redirect(url_for('auth.student_login_page'))

    student_user_id = session['student_id']
    conn = None
    cursor = None
    try:
        conn = get_db_connection()
        if not conn:
            flash("Database connection error.", "danger")
            return redirect(url_for('views.application_status_page'))

        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT * FROM applicants WHERE applicant_id = %s AND student_user_id = %s", (applicant_id, student_user_id))
        application = cursor.fetchone()
        if not application:
            flash("Invalid application.", "danger")
            return redirect(url_for('views.application_status_page'))

        student_type = request.form.get('student_type')
        year_level = request.form.get('year_level')
        semester = request.form.get('semester')

        if not all([student_type, year_level, semester]):
            flash("Please fill all required fields.", "danger")
            return redirect(url_for('auth.enrollment_form_page', applicant_id=applicant_id))

        # Base update
        update_clauses = [
            "enrollment_student_type = %s",
            "enrollment_year_level = %s",
            "enrollment_semester = %s",
            "application_status = 'Enrolling'",
            "last_updated_at = %s"
        ]
        update_values = [student_type, year_level, semester, datetime.datetime.now()]

        # NEW: Collect inventory form data
        inventory_fields = [
            'gender', 'age', 'religion', 'complete_address', 'mobile_number', 'facebook_account', 
            'interest_hobbies', 'health_condition', 'pre_elementary_school', 'pre_elementary_dates', 
            'pre_elementary_awards', 'elementary_school', 'elementary_dates', 'elementary_awards', 
            'secondary_school', 'secondary_dates', 'secondary_awards', 'vocational_school', 
            'vocational_dates', 'vocational_awards', 'father_name', 'father_age', 'father_status', 
            'father_education', 'father_occupation', 'father_contact', 'mother_name', 'mother_age', 
            'mother_status', 'mother_education', 'mother_occupation', 'mother_contact', 
            'parents_marital_status', 'number_of_children', 'number_of_brothers', 'number_of_sisters', 
            'guardian_name', 'guardian_relationship', 'guardian_contact', 'family_income', 
            'favorite_colors', 'favorite_sports', 'favorite_foods', 'family_description', 
            'emergency_contact_name', 'emergency_contact_number', 'emergency_contact_relationship'
        ]

        for field in inventory_fields:
            value = request.form.get(field)
            db_column = f"inventory_{field}"
            update_clauses.append(f"{db_column} = %s")
            update_values.append(value)
        
        # Handle uploads only for new students
        if student_type == 'New':
            file_fields = {
                'form138': ('Form 138', 5),
                'shs_diploma': ('SHS Diploma', 5),
                'good_moral': ('Good Moral Certificate', 5),
                'psa_birth': ('PSA Birth Certificate', 5),
                'photos_2x2': ('2x2 Photos', 5),
                'entrance_fee_proof': ('Entrance Fee Proof', 5),
                'voters_id': ('Voters ID/Comelec', 5),
                'cbs': ('Verified CBS', 5),
                'brgy_cert': ('Brgy Certification', 5)
            }
            for form_key, (desc, max_size) in file_fields.items():
                file_storage = request.files.get(form_key)
                if file_storage and file_storage.filename:
                    data, fname, mtype, err = process_uploaded_file(file_storage, desc, max_size)
                    if err:
                        flash(f"⚠️ {desc} Error: {err}", "danger")
                        return redirect(url_for('auth.enrollment_form_page', applicant_id=applicant_id))
                    if data:
                        db_data = f"enrollment_{form_key}_file"
                        db_fname = f"enrollment_{form_key}_filename"
                        db_mtype = f"enrollment_{form_key}_mimetype"
                        update_clauses.extend([f"{db_data} = %s", f"{db_fname} = %s", f"{db_mtype} = %s"])
                        update_values.extend([data, fname, mtype])

        query = f"UPDATE applicants SET {', '.join(update_clauses)} WHERE applicant_id = %s"
        update_values.append(applicant_id)
        
        update_cursor_final = conn.cursor()
        update_cursor_final.execute(query, tuple(update_values))
        conn.commit()
        update_cursor_final.close()

        flash("✅ Enrollment submitted successfully! Await admin verification.", "success")
        return redirect(url_for('views.application_status_page'))

    except Exception as e:
        flash(f"⚠️ Error submitting enrollment: {e}", "danger")
        traceback.print_exc()
        return redirect(url_for('views.application_status_page'))
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()


# ----------------- ADMIN APPLICATION MANAGEMENT API ROUTES -----------------
@auth.route('/admin/application/<int:applicant_id>/status', methods=['POST'])
def admin_update_application_status(applicant_id):
    if session.get('user_role') != 'admin': return jsonify({"success": False, "message": "Unauthorized"}), 401
    new_status = request.form.get('status')
    valid_statuses = ['Pending', 'In Review', 'Approved', 'Scheduled', 'Rejected', 'Passed', 'Failed', 'Enrolling']
    if not new_status or new_status not in valid_statuses: return jsonify({"success": False, "message": "Invalid status"}), 400

    conn = None; cursor = None 
    try:
        conn = get_db_connection()
        if not conn: return jsonify({"success": False, "message": "DB error"}), 500
        
        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT a.first_name, a.last_name, a.program_choice, a.exam_status, a.permit_control_no, su.email as student_account_email, a.email_address as application_form_email FROM applicants a LEFT JOIN student_users su ON a.student_user_id = su.id WHERE a.applicant_id = %s", (applicant_id,))
        app_info = cursor.fetchone()
        if not app_info: return jsonify({"success": False, "message": "App not found"}), 404

        email_to_notify = app_info.get('student_account_email') or app_info.get('application_form_email')
        applicant_name = f"{app_info.get('first_name','')} {app_info.get('last_name','')}".strip()
        now_dt = datetime.datetime.now()
        
        generated_permit_control_no = app_info.get('permit_control_no') 
        new_permit_control_no_generated_flag = False

        sql_update_parts = ["application_status = %s", "last_updated_at = %s"]
        params_update = [new_status, now_dt]

        if new_status in ['Approved', 'Rejected', 'Passed', 'Failed']:
            sql_update_parts.append("decision_date = %s")
            params_update.append(now_dt)
        else:
            sql_update_parts.append("decision_date = NULL") 

        if new_status == 'Approved' and not generated_permit_control_no:
            cursor.execute("SELECT MAX(CAST(permit_control_no AS UNSIGNED)) as max_pcn FROM applicants WHERE permit_control_no REGEXP '^[0-9]+$'")
            max_pcn_row = cursor.fetchone()
            next_pcn_int = 1
            if max_pcn_row and max_pcn_row['max_pcn'] is not None:
                next_pcn_int = int(max_pcn_row['max_pcn']) + 1
            generated_permit_control_no = f"{next_pcn_int:04d}" 
            new_permit_control_no_generated_flag = True
            sql_update_parts.append("permit_control_no = %s")
            params_update.append(generated_permit_control_no)
        
        if new_status in ['Pending', 'In Review', 'Rejected']:
            sql_update_parts.extend(["permit_exam_date = NULL", "permit_exam_time = NULL", "permit_testing_room = NULL"])

        params_update.append(applicant_id)
        final_sql = f"UPDATE applicants SET {', '.join(sql_update_parts)} WHERE applicant_id = %s"
        
        update_cursor = conn.cursor() 
        update_cursor.execute(final_sql, tuple(params_update))
        conn.commit()
        update_cursor.close()

        email_sent = False
        permit_details_for_email = None
        
        if new_status in ['Approved', 'Scheduled', 'Rejected', 'Passed', 'Failed'] and email_to_notify:
            if new_status == 'Scheduled' or (new_status == 'Approved' and new_permit_control_no_generated_flag):
                details_cursor = conn.cursor(dictionary=True)
                details_cursor.execute("SELECT permit_exam_date, permit_exam_time, permit_testing_room, permit_control_no FROM applicants WHERE applicant_id = %s", (applicant_id,))
                permit_data = details_cursor.fetchone()
                details_cursor.close()
                permit_details_for_email = permit_data 
            
            cursor.execute("SELECT exam_status FROM applicants WHERE applicant_id = %s", (applicant_id,))
            latest_app_info = cursor.fetchone()
            current_exam_status = latest_app_info['exam_status'] if latest_app_info else app_info.get('exam_status')

            email_sent = send_application_status_email(
                email_to_notify, 
                applicant_name, 
                new_status, 
                applicant_id, 
                app_info.get('program_choice'), 
                current_exam_status,
                permit_details=permit_details_for_email 
            )
        
        msg = f"Action processed for P2025{applicant_id:04d}: Status set to {new_status}."
        if new_permit_control_no_generated_flag:
             msg += f" Permit Control No. {generated_permit_control_no} assigned."
        
        if new_status in ['Approved', 'Scheduled', 'Rejected', 'Passed', 'Failed']:
             msg += " Notification email sent." if email_sent else " Notification email failed to send."

        effective_pcn = generated_permit_control_no if new_permit_control_no_generated_flag else app_info.get('permit_control_no')
        if permit_details_for_email and permit_details_for_email.get('permit_control_no'):
            effective_pcn = permit_details_for_email.get('permit_control_no')

        return jsonify({"success": True, "message": msg, "new_status": new_status, "applicant_id": applicant_id, "permit_control_no": effective_pcn })

    except mysql.connector.Error as db_err: 
        print(f"Database error updating status for {applicant_id}: {db_err}"); traceback.print_exc()
        return jsonify({"success": False, "message": f"Database error: {db_err.msg}"}), 500
    except Exception as e:
        print(f"Error updating status for {applicant_id}: {e}"); traceback.print_exc()
        return jsonify({"success": False, "message": "Server error"}), 500
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()


@auth.route('/admin/application/<int:applicant_id>/exam-status', methods=['POST'])
def admin_update_exam_status(applicant_id):
    if session.get('user_role') != 'admin': return jsonify({"success": False, "message": "Unauthorized"}), 401
    new_exam_status = request.form.get('exam_status')
    valid_exam_statuses = ['Passed', 'Failed', 'Not Taken', None, "null", ""]
    if new_exam_status not in valid_exam_statuses: return jsonify({"success": False, "message": "Invalid exam status."}), 400
    if new_exam_status in ["null", ""]: new_exam_status = None

    conn = None; cursor = None; app_info_cursor = None
    try:
        conn = get_db_connection()
        if not conn: return jsonify({"success": False, "message": "DB error"}), 500

        app_info_cursor = conn.cursor(dictionary=True)
        app_info_cursor.execute("SELECT a.first_name, a.last_name, a.program_choice, a.application_status, su.email as student_account_email, a.email_address as application_form_email FROM applicants a LEFT JOIN student_users su ON a.student_user_id = su.id WHERE a.applicant_id = %s", (applicant_id,))
        app_info = app_info_cursor.fetchone()
        if not app_info: return jsonify({"success": False, "message": "App not found."}), 404
        
        cursor = conn.cursor()
        cursor.execute("UPDATE applicants SET exam_status = %s, last_updated_at = NOW() WHERE applicant_id = %s", (new_exam_status, applicant_id))
        conn.commit()

        if cursor.rowcount > 0:
            email_to_notify = app_info.get('student_account_email') or app_info.get('application_form_email')
            applicant_name = f"{app_info.get('first_name','')} {app_info.get('last_name','')}".strip()
            email_sent = False
            if new_exam_status in ['Passed', 'Failed'] and email_to_notify and app_info.get('application_status') not in ['Approved', 'Scheduled', 'Rejected', 'Passed', 'Failed']:
                email_sent = send_application_status_email(email_to_notify, applicant_name, app_info.get('application_status'), applicant_id, app_info.get('program_choice'), new_exam_status)
            
            msg = f"Exam status for P2025{applicant_id:04d} to '{new_exam_status or 'Not Set'}'."
            if new_exam_status in ['Passed', 'Failed'] and email_to_notify and app_info.get('application_status') not in ['Approved', 'Scheduled', 'Rejected', 'Passed', 'Failed']:
                 msg += " Email sent." if email_sent else " Email failed."
            return jsonify({"success": True, "message": msg, "new_exam_status": new_exam_status, "applicant_id": applicant_id})
        else:
            cursor.execute("SELECT exam_status FROM applicants WHERE applicant_id = %s", (applicant_id,))
            db_status_row = cursor.fetchone()
            current_db_exam_status = db_status_row[0] if db_status_row else None 
            if current_db_exam_status == new_exam_status: 
                 return jsonify({"success": True, "message": f"Exam status already '{new_exam_status or 'Not Set'}'." , "new_exam_status": new_exam_status, "applicant_id": applicant_id})
            return jsonify({"success": False, "message": "App not found or status not updated."}), 404 
    except Exception as e:
        print(f"Error updating exam status for {applicant_id}: {e}"); traceback.print_exc()
        return jsonify({"success": False, "message": "Server error"}), 500
    finally:
        if app_info_cursor: app_info_cursor.close()
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()

@auth.route('/admin/application/<int:applicant_id>/delete', methods=['POST'])
def admin_delete_application(applicant_id):
    if session.get('user_role') != 'admin': return jsonify({"success": False, "message": "Unauthorized"}), 401
    conn = None; cursor = None
    try:
        conn = get_db_connection()
        if not conn: return jsonify({"success": False, "message": "DB error"}), 500
        cursor = conn.cursor()
        cursor.execute("DELETE FROM applicants WHERE applicant_id = %s", (applicant_id,))
        conn.commit()
        if cursor.rowcount > 0: return jsonify({"success": True, "message": f"P2025{applicant_id:04d} deleted."})
        return jsonify({"success": False, "message": "App not found"}), 404
    except Exception as e:
        print(f"Error deleting {applicant_id}: {e}"); traceback.print_exc()
        return jsonify({"success": False, "message": "Server error deleting."}), 500
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()

@auth.route('/admin/application/<int:applicant_id>/details', methods=['GET'])
def admin_get_application_details(applicant_id):
    if session.get('user_role') not in ['admin', 'president']: return jsonify({"success": False, "message": "Unauthorized"}), 401
    conn = None; cursor = None
    try:
        conn = get_db_connection()
        if not conn: return jsonify({"success": False, "message": "DB error"}), 500
        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT a.*, su.email as student_account_email FROM applicants a LEFT JOIN student_users su ON a.student_user_id = su.id WHERE a.applicant_id = %s", (applicant_id,))
        app_data = cursor.fetchone()
        if app_data:
            for key, value in app_data.items():
                if isinstance(value, (datetime.datetime, datetime.date)): app_data[key] = value.isoformat()
                elif key == 'photo' and isinstance(value, bytes):
                    fmt = "jpeg"
                    if value.startswith(b'\x89PNG\r\n\x1a\n'): fmt = "png"
                    app_data[key] = f"data:image/{fmt};base64,{base64.b64encode(value).decode('utf-8')}" if value else None
                elif key in ['shs_diploma_file', 'shs_card_file', 'birth_certificate_file']:
                    app_data[key] = bool(value)
                elif isinstance(value, bytes): 
                    try: app_data[key] = value.decode('utf-8')
                    except UnicodeDecodeError: app_data[key] = f"Binary ({len(value)} bytes)"
            return jsonify({"success": True, "data": app_data})
        return jsonify({"success": False, "message": "App not found"}), 404
    except Exception as e:
        print(f"Error fetching details for {applicant_id}: {e}"); traceback.print_exc()
        return jsonify({"success": False, "message": "Server error"}), 500
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()

# ----------------- DOCUMENT/PHOTO DOWNLOAD ROUTES -----------------
@auth.route('/applicant-photo/<int:applicant_id>')
def get_applicant_photo(applicant_id):
    is_admin_or_president = session.get('user_role') in ['admin', 'president']
    student_user_id = session.get('student_id', None)
    if not is_admin_or_president and not student_user_id: return "Unauthorized", 401

    conn = None; cursor = None
    try:
        conn = get_db_connection()
        if not conn: return "DB error", 500
        cursor = conn.cursor(dictionary=True)
        cursor.execute("SELECT photo, student_user_id FROM applicants WHERE applicant_id = %s", (applicant_id,))
        app_data = cursor.fetchone()
        if not app_data: return "Not found", 404
        if not is_admin_or_president and app_data.get('student_user_id') != student_user_id: return "Forbidden", 403
        if app_data.get('photo'):
            fmt = 'image/jpeg'
            if app_data['photo'].startswith(b'\x89PNG\r\n\x1a\n'): fmt = 'image/png'
            return Response(app_data['photo'], mimetype=fmt)
        return "No photo", 404
    except Exception as e:
        print(f"Error fetching photo for {applicant_id}: {e}"); traceback.print_exc()
        return "Server error", 500
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()

@auth.route('/applicant-document/<int:applicant_id>/<doc_type>')
def get_applicant_document(applicant_id, doc_type):
    is_admin_or_president = session.get('user_role') in ['admin', 'president']
    student_user_id = session.get('student_id', None)
    if not is_admin_or_president and not student_user_id: flash("Unauthorized.", "danger"); return redirect(request.referrer or url_for('views.home'))

    conn = None; cursor = None
    try:
        conn = get_db_connection()
        if not conn: flash("DB error.", "danger"); return redirect(request.referrer or url_for('views.home'))
        cursor = conn.cursor(dictionary=True)
        
        doc_map = {
            'diploma': ('shs_diploma_file', 'shs_diploma_filename', 'shs_diploma_mimetype'),
            'card': ('shs_card_file', 'shs_card_filename', 'shs_card_mimetype'),
            'birth_cert': ('birth_certificate_file', 'birth_certificate_filename', 'birth_certificate_mimetype')
        }
        if doc_type not in doc_map: flash("Invalid doc type.", "danger"); return redirect(request.referrer or url_for('views.home'))
        
        file_col, name_col, mime_col = doc_map[doc_type]
        cursor.execute(f"SELECT student_user_id, `{file_col}`, `{name_col}`, `{mime_col}` FROM applicants WHERE applicant_id = %s", (applicant_id,))
        app_data = cursor.fetchone()

        if not app_data: flash("App not found.", "danger"); return redirect(request.referrer or url_for('views.home'))
        if not is_admin_or_president and app_data.get('student_user_id') != student_user_id: flash("Forbidden.", "danger"); return redirect(request.referrer or url_for('views.home'))

        content, filename, mimetype = app_data.get(file_col), app_data.get(name_col), app_data.get(mime_col)
        if content and filename and mimetype:
            return send_file(io.BytesIO(content), mimetype=mimetype, as_attachment=True, download_name=filename)
        flash(f"{doc_type.title().replace('_', ' ')} not found.", "warning"); return redirect(request.referrer or url_for('views.home'))
    except Exception as e:
        print(f"Error getting doc {doc_type} for {applicant_id}: {e}"); traceback.print_exc()
        flash("Server error retrieving document.", "danger"); return redirect(request.referrer or url_for('views.home'))
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()


# ----------------- STUDENT APPLICATION EDIT ROUTES -----------------
@auth.route('/edit-application/<int:applicant_id>', methods=['GET'])
def edit_application_page(applicant_id):
    if 'student_id' not in session: flash("⚠️ Log in to edit.", "warning"); return redirect(url_for('auth.student_login_page'))
    conn = None; cursor = None
    try:
        conn = get_db_connection()
        if not conn: flash("DB error.", "danger"); return redirect(url_for('views.application_status_page'))
        cursor = conn.cursor(dictionary=True)
        
        all_programs = _get_program_list()
        
        cursor.execute("SELECT * FROM applicants WHERE applicant_id = %s AND student_user_id = %s", (applicant_id, session['student_id']))
        application = cursor.fetchone()
        if not application: flash("App not found or no permission.", "danger"); return redirect(url_for('views.application_status_page'))
        if application['application_status'] not in ['Pending', 'In Review']: flash(f"App status '{application['application_status']}' not editable.", "warning"); return redirect(url_for('views.application_status_page'))

        processed_app = application.copy()
        date_fields = ['date_of_birth', 'date_of_application', 'final_submission_date', 'permit_exam_date', 'submitted_at', 'decision_date', 'last_updated_at']
        date_input_fields = ['date_of_birth', 'date_of_application', 'final_submission_date', 'permit_exam_date']
        for field in date_fields:
            if field in processed_app and isinstance(processed_app[field], (datetime.datetime, datetime.date)):
                processed_app[field] = processed_app[field].strftime('%Y-%m-%d') if field in date_input_fields else processed_app[field].isoformat()
            elif field in date_input_fields and processed_app.get(field) is None: 
                processed_app[field] = ""

        return render_template('edit_application.html', application=processed_app, programs=all_programs, student_logged_in=True)
    except Exception as e:
        flash(f"Error loading edit page: {e}", "danger"); traceback.print_exc()
        return redirect(url_for('views.application_status_page'))
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()

@auth.route('/update-application/<int:applicant_id>', methods=['POST'])
def update_application_action(applicant_id):
    if 'student_id' not in session: flash("⚠️ Log in to update.", "warning"); return redirect(url_for('auth.student_login_page'))
    conn = None; cursor_check = None; cursor = None
    student_user_id = session['student_id']
    MAX_PHOTO_SIZE_MB, MAX_DOC_SIZE_MB = 5, 5

    try:
        conn = get_db_connection()
        if not conn: flash("DB error.", "danger"); return redirect(url_for('auth.edit_application_page', applicant_id=applicant_id))
        
        cursor_check = conn.cursor(dictionary=True)
        cursor_check.execute("SELECT student_user_id, application_status FROM applicants WHERE applicant_id = %s", (applicant_id,))
        app_to_edit = cursor_check.fetchone()
        if not app_to_edit: flash("App not found.", "danger"); return redirect(url_for('views.application_status_page'))
        if app_to_edit['student_user_id'] != student_user_id: flash("No permission.", "danger"); return redirect(url_for('views.application_status_page'))
        if app_to_edit['application_status'] not in ['Pending', 'In Review']: flash(f"App status '{app_to_edit['application_status']}' not editable.", "warning"); return redirect(url_for('views.application_status_page'))
        
        field_list_update = [
            'program_choice', 'last_name', 'first_name', 'middle_name', 'date_of_birth', 'place_of_birth', 'sex', 'civil_status',
            'religion', 'citizenship', 'mobile_number', 'email_address', 'permanent_address_street_barangay',
            'permanent_address_city_municipality', 'permanent_address_province', 'permanent_address_postal_code',
            'cultural_minority_group', 'physical_disability', 'date_of_application', 'academic_year', 'average_family_income',
            'father_name', 'father_occupation', 'father_company_address', 'father_contact_number', 'mother_maiden_name',
            'mother_occupation', 'mother_company_address', 'mother_contact_number', 'guardian_name', 'guardian_occupation',
            'guardian_company_address', 'guardian_contact_number', 'senior_high_school', 'senior_high_school_address',
            'senior_high_school_track_strand', 'senior_high_school_year_from', 'senior_high_school_year_to',
            'tertiary_school', 'tertiary_school_address', 'tertiary_course', 'tertiary_year_from', 'tertiary_year_to',
            'agreements', 'final_submission_date'
        ]
        req_text_fields_edit = [f for f in field_list_update if f not in ['middle_name', 'guardian_name', 'guardian_occupation', 'guardian_company_address', 'guardian_contact_number', 'tertiary_school', 'tertiary_school_address', 'tertiary_course', 'tertiary_year_from', 'tertiary_year_to']]
        req_date_fields_edit = ['date_of_birth', 'date_of_application', 'final_submission_date']

        update_clauses, values_for_update = [], []
        for field in field_list_update:
            val = request.form.get(field)
            if field in req_text_fields_edit and (not val or not val.strip()): flash(f"⚠️ {field.replace('_',' ').title()} required.", "danger"); return redirect(url_for('auth.edit_application_page', applicant_id=applicant_id))
            if field in req_date_fields_edit and not val: flash(f"⚠️ {field.replace('_',' ').title()} date required.", "danger"); return redirect(url_for('auth.edit_application_page', applicant_id=applicant_id))
            if field == 'agreements' and val != 'Yes': flash("⚠️ Re-agree to terms.", "danger"); return redirect(url_for('auth.edit_application_page', applicant_id=applicant_id))
            processed_val = val.strip() if val and isinstance(val, str) else val
            update_clauses.append(f"`{field}` = %s"); values_for_update.append(processed_val)
        
        file_fields_to_check = {
            'photo': ('2x2 Photo', MAX_PHOTO_SIZE_MB), 
            'shs_diploma_file_input': ('SHS Diploma', MAX_DOC_SIZE_MB),
            'shs_card_file_input': ('SHS Card', MAX_DOC_SIZE_MB),
            'birth_certificate_file_input': ('Birth Certificate', MAX_DOC_SIZE_MB)
        }
        db_file_map = {
            'photo': ['photo'], 
            'shs_diploma_file_input': ['shs_diploma_file', 'shs_diploma_filename', 'shs_diploma_mimetype'],
            'shs_card_file_input': ['shs_card_file', 'shs_card_filename', 'shs_card_mimetype'],
            'birth_certificate_file_input': ['birth_certificate_file', 'birth_certificate_filename', 'birth_certificate_mimetype']
        }

        for form_key, (desc, max_size) in file_fields_to_check.items():
            file_storage = request.files.get(form_key)
            if file_storage and file_storage.filename:
                data, fname, mtype, err = process_uploaded_file(file_storage, desc, max_size)
                if err: flash(f"⚠️ {desc} Error: {err}", "danger"); return redirect(url_for('auth.edit_application_page', applicant_id=applicant_id))
                if data:
                    if form_key == 'photo':
                        update_clauses.append("`photo` = %s"); values_for_update.append(data)
                    else:
                        update_clauses.extend([f"`{db_col}` = %s" for db_col in db_file_map[form_key]])
                        values_for_update.extend([data, fname, mtype])

        if not update_clauses: flash("No changes to update.", "info"); return redirect(url_for('auth.edit_application_page', applicant_id=applicant_id))
        update_clauses.append("`last_updated_at` = %s"); values_for_update.append(datetime.datetime.now())
        
        query = f"UPDATE applicants SET {', '.join(update_clauses)} WHERE applicant_id = %s AND student_user_id = %s"
        values_for_update.extend([applicant_id, student_user_id])

        cursor = conn.cursor()
        cursor.execute(query, tuple(values_for_update))
        conn.commit()
        flash("✅ App updated!" if cursor.rowcount > 0 else "No changes made.", "success" if cursor.rowcount > 0 else "info")
        return redirect(url_for('views.application_status_page'))

    except Exception as e:
        flash(f"⚠️ Update Error: {e}", "danger"); traceback.print_exc()
        return redirect(url_for('auth.edit_application_page', applicant_id=applicant_id))
    finally:
        if cursor_check: cursor_check.close()
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()

# ----------------- ADMIN APPLICATION EDIT ROUTES (NEW) -----------------
@auth.route('/admin/edit-application/<int:applicant_id>', methods=['GET'])
def admin_edit_application_page(applicant_id):
    if session.get('user_role') != 'admin': flash("⚠️ Log in for admin edit.", "warning"); return redirect(url_for('auth.admin'))
    conn = None; cursor = None
    try:
        conn = get_db_connection()
        if not conn: flash("DB error.", "danger"); return redirect(url_for('auth.admin_dashboard'))
        cursor = conn.cursor(dictionary=True)
        
        all_programs = _get_program_list()
        
        cursor.execute("SELECT * FROM applicants WHERE applicant_id = %s", (applicant_id,))
        application = cursor.fetchone()
        if not application: flash("App not found.", "danger"); return redirect(url_for('auth.admin_dashboard'))
        
        processed_app = application.copy()
        date_fields = ['date_of_birth', 'date_of_application', 'final_submission_date', 'permit_exam_date', 'submitted_at', 'decision_date', 'last_updated_at']
        date_input_fields = ['date_of_birth', 'date_of_application', 'final_submission_date', 'permit_exam_date']
        for field in date_fields:
            if field in processed_app and isinstance(processed_app[field], (datetime.datetime, datetime.date)):
                processed_app[field] = processed_app[field].strftime('%Y-%m-%d') if field in date_input_fields else processed_app[field].isoformat()
            elif field in date_input_fields and processed_app.get(field) is None: processed_app[field] = ""

        return render_template('admin_edit_application.html', application=processed_app, programs=all_programs, admin_logged_in=True)
    except Exception as e:
        flash(f"Error loading admin edit: {e}", "danger"); traceback.print_exc()
        return redirect(url_for('auth.admin_dashboard'))
    finally:
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()

@auth.route('/admin/update-application/<int:applicant_id>', methods=['POST'])
def admin_update_application_action(applicant_id):
    if session.get('user_role') != 'admin': flash("⚠️ Unauthorized.", "danger"); return redirect(url_for('auth.admin'))
    conn = None; cursor_check = None; cursor = None
    MAX_PHOTO_SIZE_MB, MAX_DOC_SIZE_MB = 5, 5

    try:
        conn = get_db_connection()
        if not conn: flash("DB error.", "danger"); return redirect(url_for('auth.admin_edit_application_page', applicant_id=applicant_id))
        cursor_check = conn.cursor(dictionary=True)
        cursor_check.execute("SELECT applicant_id FROM applicants WHERE applicant_id = %s", (applicant_id,))
        if not cursor_check.fetchone(): flash("App not found.", "danger"); return redirect(url_for('auth.admin_dashboard'))
        
        field_list_update_admin = [
            'program_choice', 'last_name', 'first_name', 'middle_name', 'date_of_birth', 'place_of_birth', 'sex', 'civil_status',
            'religion', 'citizenship', 'mobile_number', 'email_address', 'permanent_address_street_barangay',
            'permanent_address_city_municipality', 'permanent_address_province', 'permanent_address_postal_code',
            'cultural_minority_group', 'physical_disability', 'date_of_application', 'academic_year', 'average_family_income',
            'father_name', 'father_occupation', 'father_company_address', 'father_contact_number', 'mother_maiden_name',
            'mother_occupation', 'mother_company_address', 'mother_contact_number', 'guardian_name', 'guardian_occupation',
            'guardian_company_address', 'guardian_contact_number', 'senior_high_school', 'senior_high_school_address',
            'senior_high_school_track_strand', 'senior_high_school_year_from', 'senior_high_school_year_to',
            'tertiary_school', 'tertiary_school_address', 'tertiary_course', 'tertiary_year_from', 'tertiary_year_to',
            'agreements', 'final_submission_date'
        ]
        req_text_fields_admin_edit = [f for f in field_list_update_admin if f not in ['middle_name', 'guardian_name', 'guardian_occupation', 'guardian_company_address', 'guardian_contact_number', 'tertiary_school', 'tertiary_school_address', 'tertiary_course', 'tertiary_year_from', 'tertiary_year_to']]
        req_date_fields_admin_edit = ['date_of_birth', 'date_of_application', 'final_submission_date']

        update_clauses_admin, values_for_update_admin = [], []
        for field in field_list_update_admin:
            val = request.form.get(field)
            if field in req_text_fields_admin_edit and (not val or not val.strip()): flash(f"⚠️ {field.replace('_',' ').title()} required for admin edit.", "danger"); return redirect(url_for('auth.admin_edit_application_page', applicant_id=applicant_id))
            if field in req_date_fields_admin_edit and not val: flash(f"⚠️ {field.replace('_',' ').title()} date required for admin edit.", "danger"); return redirect(url_for('auth.admin_edit_application_page', applicant_id=applicant_id))
            processed_val = val.strip() if val and isinstance(val, str) else val
            if field == 'agreements': processed_val = 'Yes' if val == 'Yes' else 'No' 

            update_clauses_admin.append(f"`{field}` = %s"); values_for_update_admin.append(processed_val)
        
        file_fields_admin = {
            'photo': ('2x2 Photo', MAX_PHOTO_SIZE_MB), 
            'shs_diploma_file_input': ('SHS Diploma', MAX_DOC_SIZE_MB),
            'shs_card_file_input': ('SHS Card', MAX_DOC_SIZE_MB),
            'birth_certificate_file_input': ('Birth Certificate', MAX_DOC_SIZE_MB)
        }
        db_file_map_admin = {
            'photo': ['photo'], 
            'shs_diploma_file_input': ['shs_diploma_file', 'shs_diploma_filename', 'shs_diploma_mimetype'],
            'shs_card_file_input': ['shs_card_file', 'shs_card_filename', 'shs_card_mimetype'],
            'birth_certificate_file_input': ['birth_certificate_file', 'birth_certificate_filename', 'birth_certificate_mimetype']
        }

        for form_key, (desc, max_size) in file_fields_admin.items():
            file_storage = request.files.get(form_key)
            if file_storage and file_storage.filename:
                data, fname, mtype, err = process_uploaded_file(file_storage, desc, max_size)
                if err: flash(f"⚠️ {desc} Error: {err}", "danger"); return redirect(url_for('auth.admin_edit_application_page', applicant_id=applicant_id))
                if data:
                    if form_key == 'photo':
                        update_clauses_admin.append("`photo` = %s"); values_for_update_admin.append(data)
                    else:
                        update_clauses_admin.extend([f"`{db_col}` = %s" for db_col in db_file_map_admin[form_key]])
                        values_for_update_admin.extend([data, fname, mtype])
        
        if not update_clauses_admin: flash("No changes to update.", "info"); return redirect(url_for('auth.admin_edit_application_page', applicant_id=applicant_id))
        update_clauses_admin.append("`last_updated_at` = %s"); values_for_update_admin.append(datetime.datetime.now())
        
        query_admin = f"UPDATE applicants SET {', '.join(update_clauses_admin)} WHERE applicant_id = %s"
        values_for_update_admin.append(applicant_id)

        cursor = conn.cursor()
        cursor.execute(query_admin, tuple(values_for_update_admin))
        conn.commit()
        flash("✅ App updated by admin!" if cursor.rowcount > 0 else "No changes made by admin.", "success" if cursor.rowcount > 0 else "info")
        return redirect(url_for('auth.admin_dashboard'))

    except Exception as e:
        flash(f"⚠️ Admin Update Error: {e}", "danger"); traceback.print_exc()
        return redirect(url_for('auth.admin_edit_application_page', applicant_id=applicant_id))
    finally:
        if cursor_check: cursor_check.close()
        if cursor: cursor.close()
        if conn and conn.is_connected(): conn.close()